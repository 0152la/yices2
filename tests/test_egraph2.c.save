/*
 * Test egraph simplification and congruence
 * closure procedures
 */

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdlib.h>


#include "vectors.h"
#include "egraph.h"
#include "egraph_explanations.h"
#include "solver_printer.h"

#ifdef MINGW

/*
 * Need some version of random()
 * rand() exists on mingw
 */
static inline int random(void) {
  return rand();
}

#endif

#define NVARS       20
#define NCONSTANTS  10
#define NFUNS       4
#define NCOMPOSITES 100
#define NASSERTIONS 90

// k[0 .. NFUNS-1] are used as function symbols

static egraph_t egraph;
static eterm_t k[NCONSTANTS];   // constants
static eterm_t x[NVARS];        // variables
static eterm_t t[NCOMPOSITES];  // composites

/*
 * Assertions = equalities between two variables x[i] and x[j]
 */
typedef struct {
  occ_t lhs, rhs;
} assertion_t;

static assertion_t a[90];


/*
 * Build all variables and constant terms
 */
static void init_atoms() {
  uint32_t i;

  for (i=0; i<NCONSTANTS; i++) {
    k[i] = egraph_constant(&egraph);
  }  
  for (i=0; i<NVARS; i++) {
    x[i] = egraph_variable(&egraph);
  }
}


/*
 * Build function applications: arity = 3
 */
static void build_composites() {
  uint32_t i, j, z;
  occ_t f;
  occ_t arg[3];
  eterm_t tt;

  egraph_clear_newterm_flag(&egraph);

  i = 0;
  while (i<NCOMPOSITES) {
    z = ((uint32_t) random()) % NFUNS;
    f = pos_occ(k[z]);

    for (j=0; j<3; j++) {
      z = ((uint32_t) random()) % NVARS;
      arg[j] = pos_occ(x[z]);
    }

    tt = egraph_apply_term(&egraph, f, 3, arg);
    if (egraph_newterm(&egraph)) {
      // tt is a fresh term
      t[i] = tt;
      egraph_activate_composite(&egraph, tt);
      i ++;
    }
  }
}

/*
 * Generate random assertions
 */
static void build_assertions() {
  uint32_t i;
  uint32_t z, y;

  i = 0;
  while (i<NASSERTIONS) {
    z = ((uint32_t) random()) % NVARS;
    y = ((uint32_t) random()) % NVARS;
    if (z != y) {
      a[i].lhs = pos_occ(x[z]);
      a[i].rhs = pos_occ(x[y]);
      i ++;
    }
  }
}

/*
 * Print assertion i
 */
static void show_assertion(uint32_t i) {
  printf(" a[%"PRIu32"]: ", i);
  print_occurrence(stdout, a[i].lhs);
  printf(" == ");
  print_occurrence(stdout, a[i].rhs);
  printf("\n");
}

/*
 * Print all assertions in vector v
 */
static void show_explanation(ivector_t *v) {
  uint32_t i;

  for (i=0; i<v->size; i++) {
    show_assertion(v->data[i]);
  }
}

/*
 * Process all the assertions then propagate
 */
static void run_assertions() {
  uint32_t i;
  bool resu;

  for (i=0; i<NASSERTIONS; i++) {
    printf("Asserting ");
    show_assertion(i);    
    egraph_assert_eq(&egraph, a[i].lhs, a[i].rhs, i);
  }

  printf("\nPropagation\n");
  resu = egraph_propagate(&egraph);

  if (resu) {
    printf("\n*** No conflict ***\n");
  } else {
    printf("\n*** Conflict detected ***\n");
    printf("Conflicting assertions:\n");
    show_explanation(&egraph.expl_vector);
    printf("\n");
  }
}


/*
 * Explain equalities between composite terms
 */
static void show_equalities() {
  uint32_t i, j;
  occ_t t1, t2;
  ivector_t expl;

  init_ivector(&expl, 10);

  for (i=0; i<NCOMPOSITES; i++) {
    t1 = pos_occ(t[i]);
    for (j=i+1; j<NCOMPOSITES; j++) {
    //    for (j=0; j<NCOMPOSITES; j++) {
      t2 = pos_occ(t[j]);
      if (egraph_equal_occ(&egraph, t1, t2)) {
	printf("Implied eq between ");
	print_occurrence(stdout, t1);
	printf(" and ");
	print_occurrence(stdout, t2);
	printf("\nImplied equality: ");
	print_eterm(stdout, &egraph, term_of(t1));
	printf(" == ");
	print_eterm(stdout, &egraph, term_of(t2));
	printf("\n");

	ivector_reset(&expl);
	egraph_explain_equality(&egraph, t1, t2, &expl);
	printf("Explanation:\n");
	show_explanation(&expl);
	printf("\n");
      }
    }
  }

  delete_ivector(&expl);
}

/*
 * Dump: show all terms and root classes
 */
static void full_dump() {
  printf("*** TERMS ***\n");
  print_egraph_terms_details(stdout, &egraph);
  printf("\n*** CLASSES ***\n");
  print_egraph_root_classes(stdout, &egraph);
}

static void show_terms() {
  printf("*** TERMS ***\n");
  print_egraph_terms(stdout, &egraph);
  printf("\n\n");
}

/*
 * Test congruence construction/explanations
 */
static void test_basic_congruence() {
  init_egraph(&egraph);
  init_atoms();
  build_composites();  
  show_terms();
  build_assertions();
  run_assertions();
  show_equalities();
  delete_egraph(&egraph);
}



/*
 * Test equality simplification/propagation
 */
static occ_t eq[4];

static char *eq_name[4] = {
  "(eq x y)",
  "(eq x z)",
  "(eq z y)",
  "(eq u y)",
};

static char *asserted[2] = {
  "x == y",
  "z == u",
};

static void show_expl(ivector_t *v) {
  uint32_t i;

  printf("Explanation:");
  for (i=0; i<v->size; i++) {
    printf(" %s", asserted[v->data[i]]);
  }
  printf("\n");
}

static void show_eqs() {
  uint32_t i, j;
  ivector_t expl;

  init_ivector(&expl, 10);

  for (i=0; i<4; i++) {
    if (egraph_occ_is_true(&egraph, eq[i])) {
      printf("---> %s is true\n", eq_name[i]);
      ivector_reset(&expl);
      egraph_explain_equality(&egraph, eq[i], true_occ, &expl);
      show_expl(&expl);
    }

    if (egraph_occ_is_false(&egraph, eq[i])) {
      printf("---> %s is false\n", eq_name[i]);
      ivector_reset(&expl);
      egraph_explain_equality(&egraph, eq[i], false_occ, &expl);
      show_expl(&expl);
    }
  }

  for (i=0; i<3; i++) {
    for (j=i+1; j<4; j++) {
      if (egraph_equal_occ(&egraph, eq[i], eq[j])) {
	printf("---> %s == %s\n", eq_name[i], eq_name[j]);
	ivector_reset(&expl);
	egraph_explain_equality(&egraph, eq[i], eq[j], &expl);
	show_expl(&expl);
      }
    }
  }

  delete_ivector(&expl);
}

static void test_equalities() {
  eterm_t x, y, z, u;
  eterm_t eq_xy, eq_xz, eq_zy, eq_uy;
  bool resu;

  init_egraph(&egraph);
  x = egraph_variable(&egraph);
  y = egraph_variable(&egraph);
  z = egraph_variable(&egraph);
  u = egraph_variable(&egraph);

  eq_xy = egraph_eq_term(&egraph, pos_occ(x), pos_occ(y));
  egraph_activate_composite(&egraph, eq_xy);

  eq_xz = egraph_eq_term(&egraph, pos_occ(x), pos_occ(z));
  egraph_activate_composite(&egraph, eq_xz);

  eq_zy = egraph_eq_term(&egraph, pos_occ(z), pos_occ(y));
  egraph_activate_composite(&egraph, eq_zy);

  eq_uy = egraph_eq_term(&egraph, pos_occ(u), pos_occ(y));
  egraph_activate_composite(&egraph, eq_uy);

  full_dump();

  eq[0] = pos_occ(eq_xy);
  eq[1] = pos_occ(eq_xz);
  eq[2] = pos_occ(eq_zy);
  eq[3] = pos_occ(eq_uy);

  // x == y
  egraph_assert_eq(&egraph, pos_occ(x), pos_occ(y), 0);
  resu = egraph_propagate(&egraph);
  if (resu) {
    printf("\nNo conflict after x == y\n");
    show_eqs();
  } else {
    printf("\nConflitct detected\n");
    return;
  }

  // z == u
  egraph_assert_eq(&egraph, pos_occ(z), pos_occ(u), 1);
  resu = egraph_propagate(&egraph);
  if (resu) {
    printf("\nNo conflict after z == u\n");
    show_eqs();
  } else {
    printf("\nConflitct detected\n");
    return;
  }

  delete_egraph(&egraph);
}


int main() {
  test_basic_congruence();
  test_equalities();
  return 0;
}
