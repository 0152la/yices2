/*
 * The Yices SMT Solver. Copyright 2014 SRI International.
 *
 * This program may only be used subject to the noncommercial end user
 * license agreement which is downloadable along with this program.
 */

/*
 * INTERNAL TERM REPRESENTATION AND HASH CONSING
 */

/*
 * The internal terms include:
 * 1) constants:
 *    - constants of uninterpreted/scalar
 *    - global uninterpreted constants
 * 2) generic terms
 *    - ite c t1 t2
 *    - eq t1 t2
 *    - distinct t1 ... t_n
 * 3) boolean operators
 *    - or t1 ... t_n
 *    - xor t1 ... t_n
 *    - bit i u (extract bit i of a bitvector term u)
 * 4) bitvector terms and atoms
 *    - bitvector constants
 *    - power products
 *    - polynomials
 *    - bit arrays
 *    - other operations: divisions/shift
 *    - atoms: three binary predicates
 *      bv_eq t1 t2
 *      bv_ge t1 t2 (unsigned comparison: t1 >= t2)
 *      bv_sge t1 t2 (signed comparison: t1 >= t2)
 *
 * Every term is an index t in a global term table,
 * where 0 <= t <= 2^30. The two term occurrences
 * t+ and t- are encoded on 32bits (signed integer) with
 * - bit[31] = sign bit = 0
 * - bits[30 ... 1] = t
 * - bit[0] = polarity bit: 0 means t+, 1 means t-
 *
 * For a boolean term t, the occurrence t+ means p
 * and t- means (not p). All occurrences of a
 * non-boolean term t are positive.
 *
 * For every term, we keep:
 * - type[t] (index in the type table)
 * - kind[t] (what kind of term it is)
 * - desc[t] = descriptor that depends on the kind
 *
 * It is possible to attach names to term occurrences (but not directly
 * to terms). This is required to deal properly with booleans. For example,
 * we want to allow the user to give different names to t and (not t).
 */

#include "terms/bv64_constants.h"
#include "terms/terms.h"
#include "utils/hash_functions.h"
#include "utils/memalloc.h"
#include "utils/refcount_strings.h"


/*
 * Finalizer for term names in the symbol table.
 * All symbols must be generated by the clone function, and have
 * a reference counter (cf. refcount_strings.h).
 */
static void term_name_finalizer(stbl_rec_t *r) {
  string_decref(r->string);
}


/*
 * Initialize table, with initial size n.
 * - ttbl = attached type table.
 * - ptbl = attached power-product table.
 */
static void term_table_init(term_table_t *table, uint32_t n, type_table_t *ttbl, pprod_table_t *ptbl) {
  // abort if n is too large
  if (n > YICES_MAX_TERMS) {
    out_of_memory();
  }

  table->kind = (unsigned char *) safe_malloc(n * sizeof(unsigned char));
  table->type = (type_t *) safe_malloc(n * sizeof(type_t));
  table->desc = (term_desc_t *) safe_malloc(n * sizeof(term_desc_t));
  table->mark = allocate_bitvector(n);

  table->size = n;
  table->nelems = 0;
  table->free_idx = -1; // empty free list
  table->live_terms = 0;

  table->types = ttbl;
  table->pprods = ptbl;

  // initialize tables with default initial size
  init_int_htbl(&table->htbl, 0);
  init_stbl(&table->stbl, 0);
  init_ptr_hmap(&table->ntbl, 0);

  // attach the name finalizer to stbl
  stbl_set_finalizer(&table->stbl, term_name_finalizer);

  // buffers
  init_ivector(&table->ibuffer, 20);
  init_pvector(&table->pbuffer, 20);
}


/*
 * Extend the table: make it 50% larger
 */
static void term_table_extend(term_table_t *table) {
  uint32_t n;

  n = table->size + 1;
  n += n >> 1;

  // force abort if n is too large
  if (n > YICES_MAX_TERMS) {
    out_of_memory();
  }

  table->kind = (unsigned char *) safe_realloc(table->kind, n * sizeof(unsigned char));
  table->type = (type_t *) safe_realloc(table->type, n * sizeof(type_t));
  table->desc = (term_desc_t *) safe_realloc(table->desc, n * sizeof(term_desc_t));
  table->mark = extend_bitvector(table->mark, n);
  table->size = n;
}




/*
 * TERM ALLOCATION
 */

/*
 * Allocate a new term id
 * - clear its mark. Nothing else is initialized.
 */
static int32_t allocate_term_id(term_table_t *table) {
  int32_t i;

  i = table->free_idx;
  if (i >= 0) {
    table->free_idx = table->desc[i].integer;
  } else {
    i = table->nelems;
    table->nelems ++;
    if (i == table->size) {
      term_table_extend(table);
    }
    assert(i < table->size);
  }
  clr_bit(table->mark, i);
  table->live_terms ++;

  return i;
}



/*
 * Terms with integer descriptor
 * - tag = kind
 * - tau = type
 * - id = index
 */
static int32_t new_integer_term(term_table_t *table, term_kind_t tag, type_t tau, int32_t id) {
  int32_t i;

  i = allocate_term_id(table);
  table->kind[i] = tag;
  table->type[i] = tau;
  table->desc[i].integer = id;

  return i;
}


/*
 * Terms with pointer descriptor
 * - tag = kind
 * - tau = type
 * - d = descriptor
 */
static int32_t new_ptr_term(term_table_t *table, term_kind_t tag, type_t tau, void *d) {
  int32_t i;

  i = allocate_term_id(table);
  table->kind[i] = tag;
  table->type[i] = tau;
  table->desc[i].ptr = d;

  return i;
}


/*
 * Select k t: for bitvector selection.
 * - tag = kind
 * - tau = type
 * - k = select index
 * - t = select argument
 */
static int32_t new_select_term(term_table_t *table, term_kind_t tag, type_t tau, uint32_t k, term_t t) {
  int32_t i;

  i = allocate_term_id(table);
  table->kind[i] = tag;
  table->type[i] = tau;
  table->desc[i].select.idx = k;
  table->desc[i].select.arg = t;

  return i;
}



/*
 * TERM DESCRIPTORS
 */

/*
 * Limit on n when allocating a composite term descriptor of arity n.
 * If n <= MAX_COMPOSITE_TERM_ARITY then we can compute the descriptor
 * size without overflow (on 32bit).
 */
#define MAX_COMPOSITE_TERM_ARITY ((UINT32_MAX-sizeof(composite_term_t))/sizeof(term_t))


/*
 * Generic n-ary term:
 * - n = arity
 * - a[0 ... n-1] = components
 */
static composite_term_t *new_composite_term(uint32_t n, const term_t *a) {
  composite_term_t *d;
  uint32_t j;

  assert(n <= MAX_COMPOSITE_TERM_ARITY);

  d = (composite_term_t *) safe_malloc(sizeof(composite_term_t) + n * sizeof(term_t));
  d->arity = n;
  for (j=0; j<n; j++) {
    d->arg[j] = a[j];
  }

  return d;
}


/*
 * Bit-vector constant:
 * - v = array of k words where k = ceil(bitsize/32).
 */
static bvconst_term_t *new_bvconst_term(uint32_t bitsize, const uint32_t *v) {
  bvconst_term_t *d;
  uint32_t k;

  assert(bitsize > 64);

  k = (bitsize + 31) >> 5;
  d = (bvconst_term_t *) safe_malloc(sizeof(bvconst_term_t) + k * sizeof(uint32_t));
  d->bitsize = bitsize;
  bvconst_set(d->data, k, v);

  return d;
}


/*
 * Small bitvector constant
 */
static bvconst64_term_t *new_bvconst64_term(uint32_t bitsize, uint64_t v) {
  bvconst64_term_t *d;

  assert(1 <= bitsize && bitsize <= 64 && v == norm64(v, bitsize));

  d = (bvconst64_term_t *) safe_malloc(sizeof(bvconst64_term_t));
  d->bitsize = bitsize;
  d->value = v;

  return d;
}



/*
 * HASH CODES
 */

/*
 * Hash functions for polynomials, bv_polynomials, and bv64_polynomials are
 * defined in polynomials.c, bv_polynomials.c, and bv64_polynomials.c.
 * The following functions deal with the other term descriptors.
 */

/*
 * Indexed term defined by (tag, tau, id)
 */
static inline uint32_t hash_integer_term(term_kind_t tag, type_t tau, int32_t id) {
  return jenkins_hash_triple(tag, tau, id, 0x2839adee);
}

/*
 * Generic composite term: (tag, arity, arg[0] ... arg[n-1])
 */
static uint32_t hash_composite_term(term_kind_t tag, uint32_t n, const term_t *a) {
  return jenkins_hash_array((uint32_t *) a, n, (uint32_t) (0x8ede2341 + tag));
}


/*
 * Projection/bit selection: (tag, k, t)
 */
static inline uint32_t hash_select_term(term_kind_t tag, uint32_t k, term_t t) {
  return jenkins_hash_triple(tag, k, t, 0x98ab3342);
}


/*
 * Power product: since the pprod-table already does hash consing,
 * a power product r is uniquely identified by its address.
 */
static inline uint32_t hash_power_product(const pprod_t *r) {
  return jenkins_hash_ptr(r);
}


/*
 * For bitvector constant, we can use bvconst_hash defined in bv_constants.c
 */
static inline uint32_t hash_bvconst_term(uint32_t bitsize, const uint32_t *bv) {
  return bvconst_hash(bv, bitsize);
}


/*
 * 64bit constants
 */
static inline uint32_t hash_bvconst64_term(uint32_t bitsize, uint64_t v) {
  assert(v == norm64(v, bitsize));
  return jenkins_hash_mix3((uint32_t)(v >> 32), (uint32_t) v, 0xdeadbeef + bitsize);
}




/*
 * HASH CONSING
 */

/*
 * Objects for interfacing with int_hash_table
 * - each object type corresponds to a term kind
 * - it starts with a method descriptor m
 *   with three fields:
 *     m.hash: hash function
 *     m.eq: check for equality
 *     m.build: construct fresh term
 * - other fields are a term table, and all the
 *   subcomponents for the term kind.
 * - for an object o,
 *    o->m.hash(o) = hash code for o
 *    o->m.eq(o, i): check whether o equals term i
 *    o->m.build(o): add o to the term table and return its index
 */

/*
 * Terms with integer id
 * - tag = term kind
 * - tau = type
 * - id
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_kind_t tag;
  type_t tau;
  int32_t id;
} integer_term_hobj_t;


/*
 * Generic composite
 * - tag = term kind
 * - tau = type
 * - arity = n
 * - arg = array of n term occurrences
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_kind_t tag;
  type_t tau;
  uint32_t arity;
  const term_t *arg;
} composite_term_hobj_t;


/*
 * Select term
 * - tag = term kind
 * - tau = type
 * - k = index in projection/bitselect
 * - arg = term
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_kind_t tag;
  type_t tau;
  uint32_t k;
  term_t arg;
} select_term_hobj_t;


/*
 * Power product
 * - tau = type (can be int, real, or bitvector)
 * - r = power product
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  pprod_t *r;
} pprod_term_hobj_t;


/*
 * Bit-vector polynomials
 * - tau = bitvector type
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  bvarith_buffer_t *b;
  int32_t *v;
} bvpoly_term_hobj_t;


/*
 * Bit vector polynomials with small coefficients.
 * - tau = bitvector type
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  bvarith64_buffer_t *b;
  int32_t *v;
} bvpoly64_term_hobj_t;


/*
 * Bit vector constants
 * - v = value stored as an array of words
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  uint32_t bitsize;
  const uint32_t *v;
} bvconst_term_hobj_t;


/*
 * Small bit vector constants
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  uint32_t bitsize;
  uint64_t v;
} bvconst64_term_hobj_t;



/*
 * Hash functions for these objects
 */
static uint32_t hash_integer_hobj(integer_term_hobj_t *o) {
  return hash_integer_term(o->tag, o->tau, o->id);
}

static uint32_t hash_composite_hobj(composite_term_hobj_t *o) {
  return hash_composite_term(o->tag, o->arity, o->arg);
}

static uint32_t hash_select_hobj(select_term_hobj_t *o) {
  return hash_select_term(o->tag, o->k, o->arg);
}

static uint32_t hash_pprod_hobj(pprod_term_hobj_t *o) {
  return hash_power_product(o->r);
}

static uint32_t hash_bvpoly_hobj(bvpoly_term_hobj_t *o) {
  return hash_bvarith_buffer(o->b, o->v);
}

static uint32_t hash_bvpoly64_hobj(bvpoly64_term_hobj_t *o) {
  return hash_bvarith64_buffer(o->b, o->v);
}

static uint32_t hash_bvconst_hobj(bvconst_term_hobj_t *o) {
  return hash_bvconst_term(o->bitsize, o->v);
}

static uint32_t hash_bvconst64_hobj(bvconst64_term_hobj_t *o) {
  return hash_bvconst64_term(o->bitsize, o->v);
}


/*
 * Equality test: o = hash object, i = index of a term in o->tbl
 */
static bool eq_integer_hobj(integer_term_hobj_t *o, int32_t i) {
  term_table_t *table;

  table = o->tbl;
  assert(good_term_idx(table, i));

  return table->kind[i] == o->tag && table->type[i] == o->tau
    && table->desc[i].integer == o->id;
}

// test whether arrays a and b of size n are equal
static bool eq_term_arrays(const term_t *a, const term_t *b, uint32_t n) {
  uint32_t i;

  for (i=0; i<n; i++) {
    if (a[i] != b[i]) return false;
  }
  return true;
}

static bool eq_composite_hobj(composite_term_hobj_t *o, int32_t i) {
  term_table_t *table;
  composite_term_t *d;
  uint32_t n;

  table = o->tbl;
  assert(good_term_idx(table, i));

  if (table->kind[i] != o->tag) return false;

  d = table->desc[i].ptr;
  n = d->arity;
  return n == o->arity && eq_term_arrays(o->arg, d->arg, n);
}

static bool eq_select_hobj(select_term_hobj_t *o, int32_t i) {
  term_table_t *table;
  select_term_t *d;

  table = o->tbl;
  assert(good_term_idx(table, i));

  if (table->kind[i] != o->tag) return false;

  d = &table->desc[i].select;
  return d->idx == o->k && d->arg == o->arg;
}

static bool eq_pprod_hobj(pprod_term_hobj_t *o, int32_t i) {
  term_table_t *table;

  table = o->tbl;
  assert(good_term_idx(table, i));
  return table->kind[i] == POWER_PRODUCT && table->desc[i].ptr == o->r;
}

static bool eq_bvpoly_hobj(bvpoly_term_hobj_t *o, int32_t i) {
  term_table_t *table;

  table = o->tbl;
  assert(good_term_idx(table, i));

  return table->kind[i] == BV_POLY &&
    bvarith_buffer_equal_bvpoly(o->b, o->v, table->desc[i].ptr);
}

static bool eq_bvpoly64_hobj(bvpoly64_term_hobj_t *o, int32_t i) {
  term_table_t *table;

  table = o->tbl;
  assert(good_term_idx(table, i));

  return table->kind[i] == BV64_POLY &&
    bvarith64_buffer_equal_bvpoly(o->b, o->v, table->desc[i].ptr);
}

static bool eq_bvconst_hobj(bvconst_term_hobj_t *o, int32_t i) {
  term_table_t *table;
  bvconst_term_t *d;
  uint32_t n;

  table = o->tbl;
  assert(good_term_idx(table, i));

  if (table->kind[i] != BV_CONSTANT) return false;

  d = table->desc[i].ptr;
  n = d->bitsize;
  return n == o->bitsize && bvconst_eq(d->data, o->v, (n + 31) >> 5);
}

static bool eq_bvconst64_hobj(bvconst64_term_hobj_t *o, int32_t i) {
  term_table_t *table;
  bvconst64_term_t *d;

  table = o->tbl;
  assert(good_term_idx(table, i));

  if (table->kind[i] != BV64_CONSTANT) return false;

  d = table->desc[i].ptr;
  return d->bitsize == o->bitsize && d->value == o->v;
}


/*
 * Build functions: add a new term to o->tbl and return its index
 */
static int32_t build_integer_hobj(integer_term_hobj_t *o) {
  return new_integer_term(o->tbl, o->tag, o->tau, o->id);
}

static int32_t build_composite_hobj(composite_term_hobj_t *o) {
  composite_term_t *d;

  d = new_composite_term(o->arity, o->arg);
  return new_ptr_term(o->tbl, o->tag, o->tau, d);
}

static int32_t build_select_hobj(select_term_hobj_t *o) {
  return new_select_term(o->tbl, o->tag, o->tau, o->k, o->arg);
}

static int32_t build_pprod_hobj(pprod_term_hobj_t *o) {
  return new_ptr_term(o->tbl, POWER_PRODUCT, o->tau, o->r);
}

static int32_t build_bvpoly_hobj(bvpoly_term_hobj_t *o) {
  bvpoly_t *p;

  p = bvarith_buffer_get_bvpoly(o->b, o->v);
  return new_ptr_term(o->tbl, BV_POLY, o->tau, p);
}

static int32_t build_bvpoly64_hobj(bvpoly64_term_hobj_t *o) {
  bvpoly64_t *p;

  p = bvarith64_buffer_get_bvpoly(o->b, o->v);
  return new_ptr_term(o->tbl, BV64_POLY, o->tau, p);
}

static int32_t build_bvconst_hobj(bvconst_term_hobj_t *o) {
  bvconst_term_t *c;

  c = new_bvconst_term(o->bitsize, o->v);
  return new_ptr_term(o->tbl, BV_CONSTANT, o->tau, c);
}

static int32_t build_bvconst64_hobj(bvconst64_term_hobj_t *o) {
  bvconst64_term_t *c;

  c = new_bvconst64_term(o->bitsize, o->v);
  return new_ptr_term(o->tbl, BV64_CONSTANT, o->tau, c);
}




/*
 * TERM NAMES
 */

/*
 * Get the base name of term occurrence t
 * - return NULL if t has no base name
 */
char *term_name(term_table_t *table, term_t t) {
  ptr_hmap_pair_t *p;

  assert(live_term(table, t));
  p = ptr_hmap_find(&table->ntbl, t);
  if (p == NULL) {
    return NULL;
  }

  assert(p->val != NULL);
  return p->val;

}


/*
 * Assign name to term occurrence t.
 *
 * If name is already mapped to another term t' then the previous mapping
 * is hidden. The next calls to get_term_by_name will return t. After a
 * call to remove_term_name, the mapping [name --> t] is removed and
 * the previous mapping [name --> t'] is revealed.
 *
 * If t does not have a base name already, then 'name' is stored as the
 * base name for t. That's what's printed for t by the pretty printer.
 *
 * Warning: name is stored as a pointer, no copy is made; name must be
 * created via the clone_string function.
 */
void set_term_name(term_table_t *table, term_t t, char *name) {
  ptr_hmap_pair_t *p;

  assert(good_term(table, t) && name != NULL);

  // if t doesn't have a base name then
  // add mapping t --> name in ntbl
  p = ptr_hmap_get(&table->ntbl, t);
  assert(p != NULL);
  if (p->val == NULL) {
    p->val = name;
    string_incref(name);
  }

  // add mapping name --> t in the symbol table
  stbl_add(&table->stbl, name, t);
  string_incref(name);
}


/*
 * Assign name as the base name for term t
 * - if t already has a base name, then it's replaced by 'name'
 *   and the previous name's reference counter is decremented
 */
void set_term_base_name(term_table_t *table, term_t t, char *name) {
  ptr_hmap_pair_t *p;

  assert(good_term(table, t) && name != NULL);

  p = ptr_hmap_get(&table->ntbl, t);
  assert(p != NULL);
  if (p->val != NULL) {
    string_decref(p->val);
  }
  p->val = name;
  string_incref(name);
}


/*
 * Get term occurrence with the given name (or NULL_TERM)
 */
term_t get_term_by_name(term_table_t *table, const char *name) {
  // NULL_TERM = -1 and stbl_find returns -1 if name is absent
  return stbl_find(&table->stbl, name);
}


/*
 * Remove a name from the symbol table
 * - if name is not in the symbol table, nothing is done
 * - if name is mapped to a term t, then the mapping [name -> t]
 *   is removed. If name was mapped to a previous term t' then
 *   that mapping is restored.
 *
 * If name is the base name of a term t, then that remains unchanged.
 */
void remove_term_name(term_table_t *table, const char *name) {
  stbl_remove(&table->stbl, name);
}


/*
 * Clear name: remove t's base name if any.
 * - If t has name 'xxx' then 'xxx' is first removed from the symbol
 *   table (using remove_term_name) then t's base name is erased.
 * - If t doesn't have a base name, nothing is done.
 */
void clear_term_name(term_table_t *table, term_t t) {
  ptr_hmap_pair_t *p;
  char *name;

  assert(good_term(table, t));
  p = ptr_hmap_find(&table->ntbl, t);
  if (p != NULL) {
    name = p->val;
    assert(name != NULL);

    // remove the mapping t --> name from ntbl
    ptr_hmap_erase(&table->ntbl, p);

    // check whether the mapping name --> t still exists
    // in the symbol table.
    if (stbl_find(&table->stbl, name) == t) {
      stbl_remove(&table->stbl, name);
    }
    string_decref(name);
  }
}





/*
 * TERM DELETION
 */

/*
 * Delete term i:
 * - remove pos_term(i) and neg_term(i) from the name table
 * - free the descriptor if needed
 * - remove i from the hash table
 * - then add i to the free list
 *
 * IMPORTANT: i must not be accessible via the symbol table.
 * No name in the symbol table must refer to pos_term(i)
 * or neg_term(i).
 */
static void delete_term(term_table_t *table, int32_t i) {
  composite_term_t *d;
  select_term_t *s;
  bvconst_term_t *c;
  bvconst64_term_t *c64;
  uint32_t h;
  type_t tau;

  assert(good_term_idx(table, i));

  // make sure the reserved and primitive terms are
  // never deleted
  if (i <= bool_const) return;

  // remove the default name for pos_term(i)
  // and for neg_term(i) if i has boolean type
  clear_term_name(table, pos_term(i));
  tau = table->type[i];
  if (is_boolean_type(tau)) {
    clear_term_name(table, neg_term(i));
  }

  h = 0;   // stops GCC warning

  // compute hash and free descriptor
  switch (table->kind[i]) {
  case UNINTERPRETED_TERM:
    // No descriptor, no hash consing
    goto recycle;

  case CONSTANT_TERM:
    // The descriptor is an integer nothing to delete.
    h = hash_integer_term(table->kind[i], table->type[i], table->desc[i].integer);
    break;

  case ITE_TERM:
  case EQ_TERM:
  case DISTINCT_TERM:
  case OR_TERM:
  case XOR_TERM:
  case BV_ARRAY:
  case BV_DIV:
  case BV_REM:
  case BV_SDIV:
  case BV_SREM:
  case BV_SMOD:
  case BV_SHL:
  case BV_LSHR:
  case BV_ASHR:
  case BV_EQ_ATOM:
  case BV_GE_ATOM:
  case BV_SGE_ATOM:
    // Generic composite
    d = table->desc[i].ptr;
    h = hash_composite_term(table->kind[i], d->arity, d->arg);
    safe_free(d);
    break;

  case BIT_TERM:
    // Select term: nothing to delete.
    s = &table->desc[i].select;
    h = hash_select_term(table->kind[i], s->idx, s->arg);
    break;

  case POWER_PRODUCT:
    // Power products are deleted in garbage collection of pprod.
    h = hash_power_product(table->desc[i].ptr);
    break;

  case BV64_CONSTANT:
    c64 = table->desc[i].ptr;
    h = hash_bvconst64_term(c64->bitsize, c64->value);
    safe_free(c64);
    break;

  case BV_CONSTANT:
    c = table->desc[i].ptr;
    h = hash_bvconst_term(c->bitsize, c->data);
    safe_free(c);
    break;

  case BV64_POLY:
    h = hash_bvpoly64(table->desc[i].ptr);
    free_bvpoly64(table->desc[i].ptr);
    break;

  case BV_POLY:
    h = hash_bvpoly(table->desc[i].ptr);
    free_bvpoly(table->desc[i].ptr);
    break;

  case UNUSED_TERM:
  case RESERVED_TERM:
  default:
    assert(false);
    break;
  }

  // Remove the record [h, i] from the hash-consing table
  int_htbl_erase_record(&table->htbl, h, i);

  // Put i in the free list
 recycle:
  table->desc[i].integer = table->free_idx;
  table->free_idx = i;
  table->kind[i] = UNUSED_TERM;

  assert(table->live_terms > 0);
  table->live_terms --;
}







/*
 * TABLE INITIALIZATION
 */

/*
 * Build a dummy term at index 0 (to make sure nothing collides
 * with the const_idx used in rationals and bitvector polynomials).
 *
 * Add the boolean constant.
 */
static void add_primitive_terms(term_table_t *table) {
  int32_t i;

  i = allocate_term_id(table);
  assert(i == const_idx);
  table->kind[i] = RESERVED_TERM;
  table->type[i] = NULL_TYPE;
  table->desc[i].ptr = NULL;

  i = constant_term(table, bool_type(table->types), 0);
  assert(i == true_term);
}


/*
 * Initialize table with initial size = n.
 * Create the built-in constants and reserved term
 */
void init_term_table(term_table_t *table, uint32_t n, type_table_t *ttbl, pprod_table_t *ptbl) {
  term_table_init(table, n, ttbl, ptbl);
  add_primitive_terms(table);
}





/*
 * TABLE DELETION
 */

/*
 * Delete the name table: call decref on all strings.
 */
static void delete_name_table(ptr_hmap_t *table) {
  ptr_hmap_pair_t *p;

  p = ptr_hmap_first_record(table);
  while (p != NULL) {
    assert(p->val != NULL);
    string_decref(p->val);
    p = ptr_hmap_next_record(table, p);
  }

  delete_ptr_hmap(table);
}


/*
 * Delete all the term descriptors
 */
static void delete_term_descriptors(term_table_t *table) {
  uint32_t i, n;

  n = table->nelems;
  for (i=0; i<n; i++) {
    switch (table->kind[i]) {
    case UNUSED_TERM:
    case RESERVED_TERM:
    case CONSTANT_TERM:
    case UNINTERPRETED_TERM:
    case POWER_PRODUCT:
    case BIT_TERM:
      break;

    case ITE_TERM:
    case EQ_TERM:
    case DISTINCT_TERM:
    case OR_TERM:
    case XOR_TERM:
    case BV64_CONSTANT:
    case BV_CONSTANT:
    case BV_ARRAY:
    case BV_DIV:
    case BV_REM:
    case BV_SDIV:
    case BV_SREM:
    case BV_SMOD:
    case BV_SHL:
    case BV_LSHR:
    case BV_ASHR:
    case BV_EQ_ATOM:
    case BV_GE_ATOM:
    case BV_SGE_ATOM:
      safe_free(table->desc[i].ptr);
      break;

    case BV64_POLY:
      free_bvpoly64(table->desc[i].ptr);
      break;

    case BV_POLY:
      free_bvpoly(table->desc[i].ptr);
      break;

    default:
      assert(false);
      break;
    }
  }
}



/*
 * Delete table
 */
void delete_term_table(term_table_t *table) {
  delete_name_table(&table->ntbl);
  delete_term_descriptors(table);
  delete_int_htbl(&table->htbl);
  delete_stbl(&table->stbl);

  delete_ivector(&table->ibuffer);
  delete_pvector(&table->pbuffer);

  safe_free(table->kind);
  safe_free(table->type);
  safe_free(table->desc);
  delete_bitvector(table->mark);

  table->kind = NULL;
  table->type = NULL;
  table->desc = NULL;
  table->mark = NULL;
}



/*
 * RESET
 */

/*
 * Reset the name table: first call decref on all strings
 */
static void reset_name_table(ptr_hmap_t *table) {
  ptr_hmap_pair_t *p;

  p = ptr_hmap_first_record(table);
  while (p != NULL) {
    assert(p->val != NULL);
    string_decref(p->val);
    p = ptr_hmap_next_record(table, p);
  }
  ptr_hmap_reset(table);
}


/*
 * Full reset: delete all terms, reset the symbol table,
 * and all internal structures.
 */
void reset_term_table(term_table_t *table) {
  reset_name_table(&table->ntbl);
  delete_term_descriptors(table);
  reset_int_htbl(&table->htbl);
  reset_stbl(&table->stbl);

  ivector_reset(&table->ibuffer);
  pvector_reset(&table->pbuffer);

  table->nelems = 0;
  table->free_idx = -1;
  table->live_terms = 0;

  add_primitive_terms(table);
}


/*
 * TYPE COMPUTATIONS
 */


/*
 * Power product r
 * - r must not be a tagged variable or empty_pp or end_pp
 * - we assume r is well formed:  all variables of r are bitvectors of the same type
 * - type of r = type of the first variable.
 */
static type_t type_of_pprod(term_table_t *table, pprod_t *r) {
  return term_type(table, r->prod[0].var);
}




/*
 * TERM CONSTRUCTORS
 */

/*
 * Constant of the given type and index.
 * - tau must be uninterpreted or scalar
 * - if tau is scalar of cardinality n, then index must be between 0 and n-1
 */
term_t constant_term(term_table_t *table, type_t tau, int32_t index) {
  integer_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_integer_hobj;
  hobj.m.eq = (hobj_eq_t) eq_integer_hobj;
  hobj.m.build = (hobj_build_t) build_integer_hobj;
  hobj.tbl = table;
  hobj.tag = CONSTANT_TERM;
  hobj.tau = tau;
  hobj.id = index;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * Declare a new uninterpreted constant of type tau.
 * - this always creates a fresh term
 */
term_t new_uninterpreted_term(term_table_t *table, type_t tau) {
  int32_t i;

  i = allocate_term_id(table);
  table->kind[i] = UNINTERPRETED_TERM;
  table->type[i] = tau;
  table->desc[i].ptr = NULL;

  return pos_term(i);
}


/*
 * Negation: just flip the polarity bit
 * - p must be boolean
 */
term_t not_term(term_table_t *table, term_t p) {
  assert(is_boolean_term(table, p));
  return opposite_term(p);
}


/*
 * If-then-else term (if cond then left else right)
 * - tau must be the super type of left/right.
 */
term_t ite_term(term_table_t *table, type_t tau, term_t cond, term_t left, term_t right) {
  composite_term_hobj_t hobj;
  term_t aux[3];
  int32_t i;

  aux[0] = cond;
  aux[1] = left;
  aux[2] = right;

  hobj.m.hash = (hobj_hash_t) hash_composite_hobj;
  hobj.m.eq = (hobj_eq_t) eq_composite_hobj;
  hobj.m.build = (hobj_build_t) build_composite_hobj;

  hobj.tbl = table;
  hobj.tag = ITE_TERM;
  hobj.tau = tau;
  hobj.arity = 3;
  hobj.arg = aux;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * Binary term defined by (tag, tau, left, right)
 */
static term_t binary_term(term_table_t *table, term_kind_t tag, type_t tau, term_t left, term_t right) {
  composite_term_hobj_t hobj;
  term_t aux[2];
  int32_t i;

  aux[0] = left;
  aux[1] = right;

  hobj.m.hash = (hobj_hash_t) hash_composite_hobj;
  hobj.m.eq = (hobj_eq_t) eq_composite_hobj;
  hobj.m.build = (hobj_build_t) build_composite_hobj;
  hobj.tbl = table;
  hobj.tag = tag;
  hobj.tau = tau;
  hobj.arity = 2;
  hobj.arg = aux;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * Equality (eq left right)
 */
term_t eq_term(term_table_t *table, term_t left, term_t right) {
  return binary_term(table, EQ_TERM, bool_type(table->types), left, right);
}


/*
 * (distinct arg[0] ... arg[n-1])
 */
term_t distinct_term(term_table_t *table, uint32_t n, const term_t arg[]) {
  composite_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_composite_hobj;
  hobj.m.eq = (hobj_eq_t) eq_composite_hobj;
  hobj.m.build = (hobj_build_t) build_composite_hobj;
  hobj.tbl = table;
  hobj.tag = DISTINCT_TERM;
  hobj.tau = bool_type(table->types);
  hobj.arity = n;
  hobj.arg = arg;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * (or arg[0] ... arg[n-1])
 */
term_t or_term(term_table_t *table, uint32_t n, const term_t arg[]) {
  composite_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_composite_hobj;
  hobj.m.eq = (hobj_eq_t) eq_composite_hobj;
  hobj.m.build = (hobj_build_t) build_composite_hobj;
  hobj.tbl = table;
  hobj.tag = OR_TERM;
  hobj.tau = bool_type(table->types);
  hobj.arity = n;
  hobj.arg = arg;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * (xor arg[0] ... arg[n-1])
 */
term_t xor_term(term_table_t *table, uint32_t n, const term_t arg[]) {
  composite_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_composite_hobj;
  hobj.m.eq = (hobj_eq_t) eq_composite_hobj;
  hobj.m.build = (hobj_build_t) build_composite_hobj;
  hobj.tbl = table;
  hobj.tag = XOR_TERM;
  hobj.tau = bool_type(table->types);
  hobj.arity = n;
  hobj.arg = arg;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * Bit-select: get bit k of bit-vector bv
 */
term_t bit_term(term_table_t *table, uint32_t k, term_t bv) {
  select_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_select_hobj;
  hobj.m.eq = (hobj_eq_t) eq_select_hobj;
  hobj.m.build = (hobj_build_t) build_select_hobj;
  hobj.tbl = table;
  hobj.tag = BIT_TERM;
  hobj.tau = bool_type(table->types);
  hobj.k = k;
  hobj.arg = bv;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * Power product: r must be valid in table->ptbl, and must not be a tagged
 * variable or empty_pp.
 * - each variable index x_i in r must be a term defined in table
 * - the x_i's must be bitvector terms of the same type.
 * The type of the result is determined from the x_i's types:
 * - if all x_i's have type (bitvector k), the result has type (bitvector k)
 */
term_t pprod_term(term_table_t *table, pprod_t *r) {
  pprod_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_pprod_hobj;
  hobj.m.eq = (hobj_eq_t) eq_pprod_hobj;
  hobj.m.build = (hobj_build_t) build_pprod_hobj;
  hobj.tbl = table;
  hobj.tau = type_of_pprod(table, r);
  hobj.r = r;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * Small bitvector constant
 * - n = bitsize (must be between 1 and 64)
 * - bv = value (must be normalized modulo 2^n)
 */
term_t bv64_constant(term_table_t *table, uint32_t n, uint64_t bv) {
  bvconst64_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_bvconst64_hobj;
  hobj.m.eq = (hobj_eq_t) eq_bvconst64_hobj;
  hobj.m.build = (hobj_build_t) build_bvconst64_hobj;
  hobj.tbl = table;
  hobj.tau = bv_type(table->types, n);
  hobj.bitsize = n;
  hobj.v = bv;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * Bitvector constant:
 * - n = bitsize
 * - bv = array of k words (where k = ceil(n/32))
 * The constant must be normalized (modulo 2^n)
 * This constructor should be used only for n > 64.
 */
term_t bvconst_term(term_table_t *table, uint32_t n, const uint32_t *bv) {
  bvconst_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_bvconst_hobj;
  hobj.m.eq = (hobj_eq_t) eq_bvconst_hobj;
  hobj.m.build = (hobj_build_t) build_bvconst_hobj;
  hobj.tbl = table;
  hobj.tau = bv_type(table->types, n);
  hobj.bitsize = n;
  hobj.v = bv;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}


/*
 * Bitvector formed of arg[0] ... arg[n-1]
 * - n must be positive and no more than YICES_MAX_BVSIZE
 * - arg[0] ... arg[n-1] must be boolean terms
 */
term_t bvarray_term(term_table_t *table, uint32_t n, const term_t arg[]) {
  composite_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_composite_hobj;
  hobj.m.eq = (hobj_eq_t) eq_composite_hobj;
  hobj.m.build = (hobj_build_t) build_composite_hobj;
  hobj.tbl = table;
  hobj.tag = BV_ARRAY;
  hobj.tau = bv_type(table->types, n);
  hobj.arity = n;
  hobj.arg = arg;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  return pos_term(i);
}



/*
 * Division and shift operators
 * - the two arguments must be bitvector terms of the same type
 * - in the division/remainder operators, b is the divisor
 * - in the shift operator: a is the bitvector to be shifted
 *   and b is the shift amount
 * - in all cases, the result has the same type as a and b
 */
term_t bvdiv_term(term_table_t *table, term_t a, term_t b) {
  return binary_term(table, BV_DIV, term_type(table, a), a, b);
}

term_t bvrem_term(term_table_t *table, term_t a, term_t b) {
  return binary_term(table, BV_REM, term_type(table, a), a, b);
}

term_t bvsdiv_term(term_table_t *table, term_t a, term_t b) {
  return binary_term(table, BV_SDIV, term_type(table, a), a, b);
}

term_t bvsrem_term(term_table_t *table, term_t a, term_t b) {
  return binary_term(table, BV_SREM, term_type(table, a), a, b);
}

term_t bvsmod_term(term_table_t *table, term_t a, term_t b) {
  return binary_term(table, BV_SMOD, term_type(table, a), a, b);
}

term_t bvshl_term(term_table_t *table, term_t a, term_t b) {
  return binary_term(table, BV_SHL, term_type(table, a), a, b);
}

term_t bvlshr_term(term_table_t *table, term_t a, term_t b) {
  return binary_term(table, BV_LSHR, term_type(table, a), a, b);
}

term_t bvashr_term(term_table_t *table, term_t a, term_t b) {
  return binary_term(table, BV_ASHR, term_type(table, a), a, b);
}


/*
 * Bitvector atoms: l and r must be bitvector terms of the same type
 *  (bveq l r): l == r
 *  (bvge l r): l >= r unsigned
 *  (bvsge l r): l >= r signed
 */
term_t bveq_atom(term_table_t *table, term_t l, term_t r) {
  return binary_term(table, BV_EQ_ATOM, bool_type(table->types), l, r);
}

term_t bvge_atom(term_table_t *table, term_t l, term_t r) {
  return binary_term(table, BV_GE_ATOM, bool_type(table->types), l, r);
}

term_t bvsge_atom(term_table_t *table, term_t l, term_t r) {
  return binary_term(table, BV_SGE_ATOM, bool_type(table->types), l, r);
}




/*
 * POLYNOMIAL TERM CONSTRUCTORS
 */

/*
 * Convert power product r to an equivalent integer index
 * - empty_pp --> const_idx
 * - tagged variable x --> x (x must be a term)
 * - otherwise, build a power product term t for r and return t
 */
static int32_t poly_index_for_pprod(term_table_t *table, pprod_t *r) {
  int32_t i;

  assert(r != end_pp);

  if (pp_is_empty(r)) {
    i = const_idx;
  } else if (pp_is_var(r)) {
    i = var_of_pp(r);
  } else {
    i = pprod_term(table, r);
  }

  return i;
}


/*
 * Bitvector polynomials are constructed from a buffer b
 * - all variables of b must be bitvector terms defined in table
 * - b must be normalized and b->ptbl must be the same as table->ptbl
 * - if b contains non-linear terms, then the power products that
 *   occur in b are converted to terms (using pprod_term) then
 *   a polynomial object is created.
 *
 * SIDE EFFECT: b is reset to zero.
 */
term_t bv64_poly(term_table_t *table, bvarith64_buffer_t *b) {
  bvpoly64_term_hobj_t hobj;
  bvmlist64_t *q;
  int32_t *v;
  int32_t i;
  uint32_t j, n;

  assert(b->ptbl == table->pprods);

  n = b->nterms;

  /*
   * Convert the power products.
   * Store the results in ibuffer.
   */
  assert(table->ibuffer.size == 0);
  resize_ivector(&table->ibuffer, n + 1);
  v = table->ibuffer.data;
  q = b->list;
  for (j=0; j<n; j++) {
    assert(q->next != NULL);
    v[j] = poly_index_for_pprod(table, q->prod);
    q = q->next;
  }

  assert(q->next == NULL && q->prod == end_pp);
  v[j] = max_idx;

  // hash consing
  hobj.m.hash = (hobj_hash_t) hash_bvpoly64_hobj;
  hobj.m.eq = (hobj_eq_t) eq_bvpoly64_hobj;
  hobj.m.build = (hobj_build_t) build_bvpoly64_hobj;
  hobj.tbl = table;
  hobj.tau = bv_type(table->types, b->bitsize);
  hobj.b = b;
  hobj.v = v;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  // cleanup ibuffer
  ivector_reset(&table->ibuffer);

  return pos_term(i);
}


term_t bv_poly(term_table_t *table, bvarith_buffer_t *b) {
  bvpoly_term_hobj_t hobj;
  bvmlist_t *q;
  int32_t *v;
  int32_t i;
  uint32_t j, n;

  assert(b->ptbl == table->pprods);

  n = b->nterms;

  /*
   * Convert the power products.
   * Store the results in ibuffer.
   */
  assert(table->ibuffer.size == 0);
  resize_ivector(&table->ibuffer, n+1);
  v = table->ibuffer.data;
  q = b->list;
  for (j=0; j<n; j++) {
    assert(q->next != NULL);
    v[j] = poly_index_for_pprod(table, q->prod);
    q = q->next;
  }

  assert(q->next == NULL && q->prod == end_pp);
  v[j] = max_idx;

  // hash consing
  hobj.m.hash = (hobj_hash_t) hash_bvpoly_hobj;
  hobj.m.eq = (hobj_eq_t) eq_bvpoly_hobj;
  hobj.m.build = (hobj_build_t) build_bvpoly_hobj;
  hobj.tbl = table;
  hobj.tau = bv_type(table->types, b->bitsize);
  hobj.b = b;
  hobj.v = v;

  i = int_htbl_get_obj(&table->htbl, &hobj.m);

  // cleanup ibuffer
  ivector_reset(&table->ibuffer);

  return pos_term(i);
}





/**********************************
 *  CONVERSION TO POWER PRODUCTS  *
 *********************************/

/*
 * Convert term t to a power product:
 * - t must be a term (not a term index) present in the table
 */
pprod_t *pprod_for_term(term_table_t *table, term_t t) {
  pprod_t *r;
  int32_t i;

  assert(is_pos_term(t) && good_term(table, t));
  assert(is_bitvector_term(table, t));

  r = var_pp(t);
  i = index_of(t);
  if (table->kind[i] == POWER_PRODUCT) {
    r = table->desc[i].ptr;
  }
  return r;
}


/*
 * Degree of x where x = main variable of a polynomial
 */
static uint32_t main_var_degree(term_table_t *table, int32_t x) {
  uint32_t d;

  d = 1;
  if (x == const_idx) {
    d = 0;
  } else {
    assert(is_pos_term(x) && good_term(table, x));
    x = index_of(x);
    if (table->kind[x] == POWER_PRODUCT) {
      d = pprod_degree(table->desc[x].ptr);
    }
  }

  return d;
}


/*
 * Degree of term t
 * - t must be a good term of arithmetic or bitvector type
 */
uint32_t term_degree(term_table_t *table, term_t t) {
  uint32_t d;
  int32_t i;

  assert(is_pos_term(t) && good_term(table, t));
  assert(is_bitvector_term(table, t));

  d = 1;
  i = index_of(t);
  switch (table->kind[i]) {
  case POWER_PRODUCT:
    d = pprod_degree(table->desc[i].ptr);
    break;

  case BV64_CONSTANT:
  case BV_CONSTANT:
    d = 0;
    break;

  case BV64_POLY:
    d = main_var_degree(table, bvpoly64_main_var(table->desc[i].ptr));
    break;

  case BV_POLY:
    d = main_var_degree(table, bvpoly_main_var(table->desc[i].ptr));
    break;
  }

  return d;
}


/*
 * Convert all variables of p to power products
 * - store the result in table->pbuffer
 * - return the array of power products
 */
pprod_t **pprods_for_bvpoly64(term_table_t *table, const bvpoly64_t *p) {
  uint32_t i, n;
  void **v;

  n = p->nterms;
  resize_pvector(&table->pbuffer, n+1);
  v = table->pbuffer.data;
  i = 0;

  // the constant is first in p
  if (p->mono[0].var == const_idx) {
    v[0] = empty_pp;
    i = 1;
  }

  // rest of p
  while (i < n) {
    v[i] = pprod_for_term(table, p->mono[i].var);
    i ++;
  }
  // end marker
  assert(p->mono[i].var == max_idx);
  v[i] = end_pp;

  return (pprod_t **) v;
}


/*
 * Convert all variables of p to power products
 * - store the result in table->pbuffer
 * - return the array of power products
 */
pprod_t **pprods_for_bvpoly(term_table_t *table, const bvpoly_t *p) {
  uint32_t i, n;
  void **v;

  n = p->nterms;
  resize_pvector(&table->pbuffer, n+1);
  v = table->pbuffer.data;
  i = 0;

  // the constant is first in p
  if (p->mono[0].var == const_idx) {
    v[0] = empty_pp;
    i = 1;
  }

  // rest of p
  while (i < n) {
    v[i] = pprod_for_term(table, p->mono[i].var);
    i ++;
  }
  // end marker
  assert(p->mono[i].var == max_idx);
  v[i] = end_pp;

  return (pprod_t **) v;
}


/*
 * CHECKS ON TERMS
 */

/*
 * Good term: valid descriptor + polarity = 0 unless
 * t is a Boolean term.
 */
bool good_term(term_table_t *table, term_t t) {
  return good_term_idx(table, index_of(t)) &&
    (is_pos_term(t) || type_for_idx(table, index_of(t)) == bool_id);
}


/*******************************
 *  CHECKS ON ATOMS/LITERALS   *
 ******************************/

/*
 * Test whether t is a bitvector literal
 */
bool is_bitvector_literal(term_table_t *table, term_t t) {
  switch (term_kind(table, t)) {
  case BV_EQ_ATOM:
  case BV_GE_ATOM:
  case BV_SGE_ATOM:
    return true;

  default:
    return false;
  }
}


/********************
 *  CONSTANT TERMS  *
 *******************/

/*
 * Generic version: return true if t is an atomic constant
 * or a constant tuple.
 */
bool is_constant_term(term_table_t *table, term_t t) {
  return is_const_term(table, t);
}


/*
 * Check whether the table contains a constant term of type tau and the given index
 * - tau must be uninterpreted or scalar
 * - if tau is scalar, then index must be between 0 and cardinality of tau - 1
 * - return NULL_TERM if there's no such term in table
 */
term_t find_constant_term(term_table_t *table, type_t tau, int32_t index) {
  integer_term_hobj_t hobj;
  int32_t i;

  hobj.m.hash = (hobj_hash_t) hash_integer_hobj;
  hobj.m.eq = (hobj_eq_t) eq_integer_hobj;
  hobj.m.build = NULL; 
  hobj.tbl = table;
  hobj.tag = CONSTANT_TERM;
  hobj.tau = tau;
  hobj.id = index;

  i = int_htbl_find_obj(&table->htbl, &hobj.m);
  if (i >= 0) {
    i = pos_term(i);
  }

  assert(i == NULL_TERM || 
         (term_kind(table, i) == CONSTANT_TERM && term_type(table, i) == tau 
          && constant_term_index(table, i) == index));

  return i;
}





/***********************
 * GARBAGE COLLECTION  *
 **********************/

/*
 * MARKING
 */

/*
 * Mark all descendants of i whose ids are less than ptr
 * - i must be a marked term index and not already deleted.
 *
 * NOTE: check for risks for stack overflow here.
 */
static void mark_reachable_terms(term_table_t *table, int32_t ptr, int32_t i);

// mark i if it's not already marked then explore its children if i < ptr where i = index_of(t)
static void mark_and_explore_term(term_table_t *table, int32_t ptr, term_t t) {
  int32_t i;

  i = index_of(t);
  if (! term_idx_is_marked(table, i)) {
    term_table_set_gc_mark(table, i);
    if (i < ptr) {
      mark_reachable_terms(table, ptr, i);
    }
  }
}

// mark all terms in composite term d
static void mark_composite_term(term_table_t *table, int32_t ptr, composite_term_t *d) {
  uint32_t i, n;

  n = d->arity;
  for (i=0; i<n; i++) {
    mark_and_explore_term(table, ptr, d->arg[i]);
  }
}

// subterm of d
static inline void mark_select_term(term_table_t *table, int32_t ptr, select_term_t *d) {
  mark_and_explore_term(table, ptr, d->arg);
}

// variables in polynomials
static void mark_bvpoly(term_table_t *table, int32_t ptr, bvpoly_t *p) {
  bvmono_t *q;

  q = p->mono;
  // skip constant monomial if any
  if (q->var == const_idx) q ++;

  while (q->var != max_idx) {
    mark_and_explore_term(table, ptr, q->var);
    q ++;
  }
}

static void mark_bvpoly64(term_table_t *table, int32_t ptr, bvpoly64_t *p) {
  bvmono64_t *q;

  q = p->mono;
  // skip constant monomial if any
  if (q->var == const_idx) q ++;

  while (q->var != max_idx) {
    mark_and_explore_term(table, ptr, q->var);
    q ++;
  }
}


// power product r: we mark it in table->pprods, then we explore all variables of r
static void mark_power_product(term_table_t *table, int32_t ptr, pprod_t *r) {
  uint32_t i, n;

  assert(r != empty_pp && r != end_pp && !pp_is_var(r));
  pprod_table_set_gc_mark(table->pprods, r);

  n = r->len;
  for (i=0; i<n; i++) {
    mark_and_explore_term(table, ptr, r->prod[i].var);
  }
}


static void mark_reachable_terms(term_table_t *table, int32_t ptr, int32_t i) {
  assert(term_idx_is_marked(table, i));

  switch (table->kind[i]) {
  case UNUSED_TERM:
  case RESERVED_TERM:
  case CONSTANT_TERM:
  case BV64_CONSTANT:
  case BV_CONSTANT:
  case UNINTERPRETED_TERM:
    // leaf terms
    break;

  case ITE_TERM:
  case EQ_TERM:
  case DISTINCT_TERM:
  case OR_TERM:
  case XOR_TERM:
  case BV_ARRAY:
  case BV_DIV:
  case BV_REM:
  case BV_SDIV:
  case BV_SREM:
  case BV_SMOD:
  case BV_SHL:
  case BV_LSHR:
  case BV_ASHR:
  case BV_EQ_ATOM:
  case BV_GE_ATOM:
  case BV_SGE_ATOM:
    // i's descriptor is a composite term
    mark_composite_term(table, ptr, table->desc[i].ptr);
    break;

  case BIT_TERM:
    // i's descriptor is a select term
    mark_select_term(table, ptr, &table->desc[i].select);
    break;

  case POWER_PRODUCT:
    mark_power_product(table, ptr, table->desc[i].ptr);
    break;

  case BV64_POLY:
    mark_bvpoly64(table, ptr, table->desc[i].ptr);
    break;

  case BV_POLY:
    mark_bvpoly(table, ptr, table->desc[i].ptr);
    break;

  default:
    assert(false);
    break;
  }

}


/*
 * Mark all live terms:
 * - on entry: the root terms must be marked
 * - on exit:
 *   every term reachable from a root term is marked
 *   every power product that's live is marked in table->ptbl.
 *   every type that's attached to a live term is marked in table->types
 */
static void mark_live_terms(term_table_t *table) {
  type_table_t *types;
  uint32_t i, n;

  n = table->nelems;
  for (i=0; i<n; i++) {
    if (term_idx_is_marked(table, i)) {
      mark_reachable_terms(table, i, i);
    }
  }

  // propagate the marks to live types
  // skip the reserved term
  types = table->types;
  for (i=1; i<n; i++) {
    if (term_idx_is_marked(table, i) ) {
      type_table_set_gc_mark(types, table->type[i]);
    }
  }
}


/*
 * Iterator to mark the terms accessible from the symbol table
 * - aux must be a pointer to the term table
 * - r is a record in the symbol table: r->value is a term to mark
 */
static void mark_symbol(void *aux, const stbl_rec_t *r) {
  term_table_set_gc_mark(aux, index_of(r->value));
}


/*
 * Filter to remove references to dead terms from the symbol table
 * - aux must be a pointer to the term table
 * - r is a record in the symbol table: if the function returns true,
 *   then r is finalized then removed from the symbol table.
 */
static bool dead_term_symbol(void *aux, const stbl_rec_t *r) {
  return !term_idx_is_marked(aux, index_of(r->value));
}


/*
 * Garbage collector
 * - the roots are all the marked terms + if keep_named is true,
 *   all the terms accessible from the symbol table (i.e., mapped to some name).
 * - every term, type, and power product reachable from these roots
 *   is preserved
 * - delete everything else
 * - clear all the marks
 */
void term_table_gc(term_table_t *table, bool keep_named) {
  uint32_t i, n;

  // mark the terms present in the symbol table
  if (keep_named) {
    stbl_iterate(&table->stbl, table, mark_symbol);
  }

  // mark the primitive terms
  set_bit(table->mark, const_idx);
  set_bit(table->mark, bool_const);

  // propagate the marks
  mark_live_terms(table);

  // remove the unmarked terms from the symbol table
  if (!keep_named) {
    stbl_remove_records(&table->stbl, table, dead_term_symbol);
  }

  // force garbage collection in the type and power-product tables
  type_table_gc(table->types, keep_named);
  pprod_table_gc(table->pprods);

  // delete the unmarked terms
  n = table->nelems;
  for (i=0; i<n; i++) {
    if (! term_idx_is_marked(table, i) && table->kind[i] != UNUSED_TERM) {
      delete_term(table, i);
    }
  }

  // clear the marks
  clear_bitvector(table->mark, table->size);
}
