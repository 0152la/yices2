/*
 * The Yices SMT Solver. Copyright 2014 SRI International.
 *
 * This program may only be used subject to the noncommercial end user
 * license agreement which is downloadable along with this program.
 */

/*
 * Type table and hash consing
 */

#include <string.h>
#include <assert.h>

#include "terms/types.h"
#include "utils/hash_functions.h"
#include "utils/memalloc.h"
#include "utils/refcount_strings.h"
#include "yices_limits.h"



/*
 * TYPE TABLE
 */

/*
 * Finalizer for typenames in the symbol table. This function is
 * called when record r is deleted from the symbol table.
 * All symbols must be generated by the clone function, and have
 * a reference counter (cf. refcount_strings.h).
 */
static void typename_finalizer(stbl_rec_t *r) {
  string_decref(r->string);
}


/*
 * Initialize table, with initial size = n.
 */
static void type_table_init(type_table_t *table, uint32_t n) {
  // abort if the size is too large
  if (n > YICES_MAX_TYPES) {
    out_of_memory();
  }

  table->kind = (uint8_t *) safe_malloc(n * sizeof(uint8_t));
  table->desc = (type_desc_t *) safe_malloc(n * sizeof(type_desc_t));
  table->card = (uint32_t *) safe_malloc(n * sizeof(uint32_t));
  table->flags = (uint8_t *) safe_malloc(n * sizeof(uint8_t));
  table->name = (char **) safe_malloc(n * sizeof(char *));

  table->size = n;
  table->nelems = 0;
  table->free_idx = NULL_TYPE;
  table->live_types = 0;

  init_int_htbl(&table->htbl, 0); // use default size
  init_stbl(&table->stbl, 0);     // default size too

  // install finalizer in the symbol table
  stbl_set_finalizer(&table->stbl, typename_finalizer);
}


/*
 * Extend the table: make it 50% larger
 */
static void type_table_extend(type_table_t *table) {
  uint32_t n;

  /*
   * new size = 1.5 * (old_size + 1) approximately
   * this computation can't overflow since old_size < YICES_MAX_TYPE
   * this also ensures that new size > old size (even if old_size <= 1).
   */
  n = table->size + 1;
  n += n >> 1;
  if (n > YICES_MAX_TYPES) {
    out_of_memory();
  }

  table->kind = (uint8_t *) safe_realloc(table->kind, n * sizeof(uint8_t));
  table->desc = (type_desc_t *) safe_realloc(table->desc, n * sizeof(type_desc_t));
  table->card = (uint32_t *) safe_realloc(table->card, n * sizeof(uint32_t));
  table->flags = (uint8_t *) safe_realloc(table->flags, n * sizeof(uint8_t));
  table->name = (char **) safe_realloc(table->name, n * sizeof(char *));

  table->size = n;
}


/*
 * Get a free type id and initializes its name to NULL.
 * The other fields are not initialized.
 */
static type_t allocate_type_id(type_table_t *table) {
  type_t i;

  i = table->free_idx;
  if (i >= 0) {
    table->free_idx = table->desc[i].next;
  } else {
    i = table->nelems;
    table->nelems ++;
    if (i >= table->size) {
      type_table_extend(table);
    }
  }
  table->name[i] = NULL;
  table->live_types ++;

  return i;
}


/*
 * Erase type i: free its descriptor and add i to the free list
 */
static void erase_type(type_table_t *table, type_t i) {
  switch (table->kind[i]) {
  case UNUSED_TYPE: // already deleted
  case BOOL_TYPE:
    return; // never delete predefined types

  case BITVECTOR_TYPE:
    break;
  }

  if (table->name[i] != NULL) {
    string_decref(table->name[i]);
    table->name[i] = NULL;
  }

  table->kind[i] = UNUSED_TYPE;
  table->desc[i].next = table->free_idx;
  table->free_idx = i;

  assert(table->live_types > 0);
  table->live_types --;
}




/*
 * TYPE CREATION
 */

/*
 * Add the predefined type
 */
static void add_primitive_types(type_table_t *table) {
  type_t i;

  i = allocate_type_id(table);
  assert(i == bool_id);
  table->kind[i] = BOOL_TYPE;
  table->desc[i].integer = 0; // not used
  table->card[i] = 2;
  table->flags[i] = SMALL_TYPE_FLAGS;
}


/*
 * Add type (bitvector k) and return its id
 * - k must be positive and no more than YICES_MAX_BVSIZE
 */
static type_t new_bitvector_type(type_table_t *table, uint32_t k) {
  type_t i;

  assert(0 < k && k <= YICES_MAX_BVSIZE);

  i = allocate_type_id(table);
  table->kind[i] = BITVECTOR_TYPE;
  table->desc[i].integer = k;
  if (k < 32) {
    table->card[i] = ((uint32_t) 1) << k;
    table->flags[i] = SMALL_TYPE_FLAGS;
  } else {
    table->card[i] = UINT32_MAX;
    table->flags[i] = LARGE_TYPE_FLAGS;
  }

  return i;
}


/*
 * HASH CONSING
 */

/*
 * Objects for hash-consing
 */
typedef struct bv_type_hobj_s {
  int_hobj_t m;      // methods
  type_table_t *tbl;
  uint32_t size;
} bv_type_hobj_t;


/*
 * Hash functions
 */
static uint32_t hash_bv_type(bv_type_hobj_t *p) {
  return jenkins_hash_pair(p->size, 0, 0x7838abe2);
}

/*
 * Hash functions used during garbage collection.
 * Make sure they are consistent with the ones above.
 */
static uint32_t hash_bvtype(int32_t size) {
  return jenkins_hash_pair(size, 0, 0x7838abe2);
}

/*
 * Comparison functions for hash consing
 */
static bool eq_bv_type(bv_type_hobj_t *p, type_t i) {
  type_table_t *table;

  table = p->tbl;
  return table->kind[i] == BITVECTOR_TYPE && table->desc[i].integer == p->size;
}

/*
 * Builder functions
 */
static type_t build_bv_type(bv_type_hobj_t *p) {
  return new_bitvector_type(p->tbl, p->size);
}


/*
 * TABLE MANAGEMENT + EXPORTED TYPE CONSTRUCTORS
 *
 * NOTE: The constructors for uninterpreted and scalar types
 * are defined above. They don't use hash consing.
 */

/*
 * Initialize table: add the predefined types
 */
void init_type_table(type_table_t *table, uint32_t n) {
  type_table_init(table, n);
  add_primitive_types(table);
}

/*
 * Delete table: free all allocated memory
 */
void delete_type_table(type_table_t *table) {
  uint32_t i;

  // decrement refcount for all names
  for (i=0; i<table->nelems; i++) {
    if (table->name[i] != NULL) {
      string_decref(table->name[i]);
    }
  }

  safe_free(table->kind);
  safe_free(table->desc);
  safe_free(table->card);
  safe_free(table->flags);
  safe_free(table->name);

  table->kind = NULL;
  table->desc = NULL;
  table->card = NULL;
  table->flags = NULL;
  table->name = NULL;

  delete_int_htbl(&table->htbl);
  delete_stbl(&table->stbl);
}


/*
 * Full reset: delete everything except the primitive types
 */
void reset_type_table(type_table_t *table) {
  uint32_t i;

  // decrement ref counts
  for (i=0; i<table->nelems; i++) {
    if (table->name[i] != NULL) {
      string_decref(table->name[i]);
    }
  }

  reset_int_htbl(&table->htbl);
  reset_stbl(&table->stbl);

  table->nelems = 0;
  table->free_idx = NULL_TYPE;
  table->live_types = 0;
  add_primitive_types(table);
}


/*
 * Bitvector type
 */
type_t bv_type(type_table_t *table, uint32_t size) {
  bv_type_hobj_t hobj;

  assert(size > 0);

  hobj.m.hash = (hobj_hash_t) hash_bv_type;
  hobj.m.eq = (hobj_eq_t) eq_bv_type;
  hobj.m.build = (hobj_build_t) build_bv_type;
  hobj.tbl = table;
  hobj.size = size;

  return int_htbl_get_obj(&table->htbl, &hobj.m);
}


/*
 * TYPE NAMES
 */

/*
 * Assign name to type i.
 * - the previous mapping of name to other types (if any) is hidden.
 * - name must have a reference counter attached to it (cf. clone_string
 *   in memalloc.h).
 */
void set_type_name(type_table_t *table, type_t i, char *name) {
  if (table->name[i] == NULL) {
    table->name[i] = name;
    string_incref(name);
  }
  stbl_add(&table->stbl, name, i);
  string_incref(name);
}

/*
 * Get type mapped to the name (or NULL_TYPE)
 */
type_t get_type_by_name(type_table_t *table, const char *name) {
  // NULL_TYPE = -1 and stbl_find returns -1 if name is absent
  return stbl_find(&table->stbl, name);
}

/*
 * Remove a type name.
 */
void remove_type_name(type_table_t *table, const char *name) {
  stbl_remove(&table->stbl, name);
}


/*
 * Remove the name of t
 */
void clear_type_name(type_table_t *table, type_t t) {
  char *name;

  name = table->name[t];
  if (name != NULL) {
    if (stbl_find(&table->stbl, name) == t) {
      stbl_remove(&table->stbl, name);
    }
    table->name[t] = NULL;
    string_decref(name);
  }
}



/*
 * SUBTYPING/COMPATIBILITY
 */

/*
 * This is all trivial since we only have bitvector and Boolean types.
 */

/*
 * Compute the smallest supertype of tau1 and tau2.
 */
type_t super_type(type_table_t *table, type_t tau1, type_t tau2) {  
  assert(good_type(table, tau1) && good_type(table, tau2));
  return (tau1 == tau2) ? tau1 : NULL_TYPE;
}

/*
 * Compute the largest common subtype of tau1 and tau2.
 */
type_t inf_type(type_table_t *table, type_t tau1, type_t tau2) {  
  assert(good_type(table, tau1) && good_type(table, tau2));
  return (tau1 == tau2) ? tau1 : NULL_TYPE;
}

/*
 * Build the largest type that's a supertype of tau
 */
type_t max_super_type(type_table_t *table, type_t tau) {
  assert(good_type(table, tau));
  return tau;
}

/*
 * Check whether tau1 is a subtype if tau2.
 */
bool is_subtype(type_table_t *table, type_t tau1, type_t tau2) {
  assert(good_type(table, tau1) && good_type(table, tau2));
  return tau1 == tau2;
}


/*
 * Check whether tau1 and tau2 are compatible.
 */
bool compatible_types(type_table_t *table, type_t tau1, type_t tau2) {
  assert(good_type(table, tau1) && good_type(table, tau2));
  return tau1 == tau2;
}



/*
 * GARBAGE COLLECTION
 */

/*
 * Remove type i from the hash-consing table
 */
static void erase_hcons_type(type_table_t *table, type_t i) {
  uint32_t k;

  switch (table->kind[i]) {
  case BITVECTOR_TYPE:
    k = hash_bvtype(table->desc[i].integer);
    break;

  default:
    return;
  }

  int_htbl_erase_record(&table->htbl, k, i);
}


/*
 * Iterator to mark types present in the symbol table
 * - aux must be a pointer to the type table
 * - r = live record in the symbol table so r->value
 *   is the id of a type to preserve.
 */
static void mark_symbol(void *aux, const stbl_rec_t *r) {
  type_table_set_gc_mark(aux, r->value);
}


/*
 * Filter to remove dead types from the symbol table.
 * - aux must be a pointer to the type table
 * - r = record in the symbol table: if the function returns true,
 *   r will be finalized then removed from the symbol table.
 */
static bool dead_type_symbol(void *aux, const stbl_rec_t *r) {
  return !type_is_marked(aux, r->value);
}


/*
 * Call the garbage collector:
 * - delete every type not reachable from a root
 * - if keep_named is true, all named types (reachable from the symbol table)
 *   are preserved. Otherwise, all live types are marked and all references
 *   to dead types are remove from the symbol table.
 * - cleanup the caches
 * - then clear all the marks
 */
void type_table_gc(type_table_t *table, bool keep_named)  {
  uint32_t i, n;

  // mark every type present in the symbol table
  if (keep_named) {
    stbl_iterate(&table->stbl, table, mark_symbol);
  }

  // mark the predefined type
  type_table_set_gc_mark(table, bool_id);

  // remove unmarked types from the symbol table
  if (!keep_named) {
    stbl_remove_records(&table->stbl, table, dead_type_symbol);
  }

  // delete every unmarked type
  n = table->nelems;
  for (i=0; i<n; i++) {
    if (! type_is_marked(table, i)) {
      erase_hcons_type(table, i);
      erase_type(table, i);
    }
    type_table_clr_gc_mark(table, i);
  }
}
