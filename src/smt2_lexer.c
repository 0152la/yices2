/*
 * Lexer for the SMT-LIB language (version 2)
 */

#include <assert.h>
#include <ctype.h>

/*
 * smt2_hash_keywords.h is generated by gperf from smt2_keywords.txt
 */

#include "smt2_lexer.h"
#include "smt2_hash_keywords.h"


/*
 * All predefined symbols
 */
static keyword_t smt2_keywords[] = {
  // reserved words
  { "par", SMT2_TK_PAR },
  { "NUMERAL", SMT2_TK_NUM },
  { "DECIMAL", SMT2_TK_DEC },
  { "STRING", SMT2_TK_STR },
  { "_", SMT2_TK_UNDERSCORE },
  { "!", SMT2_TK_BANG },
  { "as", SMT2_TK_AS },
  { "let", SMT2_TK_LET },
  { "exists", SMT2_TK_EXISTS },
  { "forall", SMT2_TK_FORALL },
  // commands
  { "assert", SMT2_TK_ASSERT },
  { "check-sat", SMT2_TK_CHECK_SAT },
  { "declare-sort", SMT2_TK_DECLARE_SORT },
  { "declare-fun", SMT2_TK_DECLARE_FUN },
  { "define-sort", SMT2_TK_DEFINE_SORT },
  { "define-fun", SMT2_TK_DEFINE_FUN },
  { "exit", SMT2_TK_EXIT },
  { "get-assertions", SMT2_TK_GET_ASSERTIONS },
  { "get-assignmnet", SMT2_TK_GET_ASSIGNMENT },
  { "get-info", SMT2_TK_GET_INFO },
  { "get-option", SMT2_TK_GET_OPTION },
  { "get-proof", SMT2_TK_GET_PROOF },
  { "get-unsat-core", SMT2_TK_GET_UNSAT_CORE },
  { "get-value", SMT2_TK_GET_VALUE },
  { "pop", SMT2_TK_POP },
  { "push", SMT2_TK_PUSH },
  { "set-logic", SMT2_TK_SET_LOGIC },
  { "set-info", SMT2_TK_SET_INFO },
  { "set-option", SMT2_TK_SET_OPTION },
  // Core theory symbols
  { "Bool", SMT2_TK_BOOL },
  { "true", SMT2_TK_TRUE },
  { "false", SMT2_TK_FALSE },
  { "not", SMT2_TK_NOT },
  { "=>", SMT2_TK_IMPLIES },
  { "and", SMT2_TK_AND },
  { "or", SMT2_TK_OR },
  { "xor", SMT2_TK_XOR },
  { "=", SMT2_TK_EQ },
  { "distinct", SMT2_TK_DISTINCT },
  { "ite", SMT2_TK_ITE },
  // Arrays
  { "Array", SMT2_TK_ARRAY },
  { "select", SMT2_TK_SELECT },
  { "store", SMT2_TK_STORE },
  // Arithmetic
  { "Int", SMT2_TK_INT },
  { "Real", SMT2_TK_REAL },
  { "-", SMT2_TK_MINUS },
  { "+", SMT2_TK_PLUS },
  { "*", SMT2_TK_TIMES },
  { "/", SMT2_TK_DIVIDES },
  { "<=", SMT2_TK_LE },
  { "<", SMT2_TK_LT },
  { ">=", SMT2_TK_GE },
  { ">", SMT2_TK_GT },
  { "div", SMT2_TK_DIV },
  { "mod", SMT2_TK_MOD },
  { "abs", SMT2_TK_ABS },
  { "to_real", SMT2_TK_TO_REAL },
  { "to_int", SMT2_TK_TO_INT },
  { "is_int", SMT2_TK_IS_INT },
  { "divisible", SMT2_TK_DIVISIBLE },
  // Bitvectors
  { "BitVec", SMT2_TK_BITVEC },
  { "concat", SMT2_TK_CONCAT },
  { "extract", SMT2_TK_EXTRACT },
  { "repeat", SMT2_TK_REPEAT },
  { "bvcomp", SMT2_TK_BVCOMP },
  { "bvnot", SMT2_TK_BVNOT },
  { "bvand", SMT2_TK_BVAND },
  { "bvor", SMT2_TK_BVOR },
  { "bvnand", SMT2_TK_BVNAND },
  { "bvnor", SMT2_TK_BVNOR },
  { "bvxor", SMT2_TK_BVXOR },
  { "bvxnor", SMT2_TK_BVXNOR },
  { "bvneg", SMT2_TK_BVNEG },
  { "bvadd", SMT2_TK_BVADD },
  { "bvsub", SMT2_TK_BVSUB },
  { "bvmul", SMT2_TK_BVMUL },
  { "bvudiv", SMT2_TK_BVUDIV },
  { "bvurem", SMT2_TK_BVUREM },
  { "bvsdiv", SMT2_TK_BVSDIV },
  { "bvsrem", SMT2_TK_BVSREM },
  { "bvsmod", SMT2_TK_BVSMOD },
  { "bvshl", SMT2_TK_BVSHL },
  { "bvlshr", SMT2_TK_BVLSHR },
  { "bvashr", SMT2_TK_BVASHR },
  { "zero_extend", SMT2_TK_ZERO_EXTEND },
  { "sign_extend", SMT2_TK_SIGN_EXTEND },
  { "rotate_left", SMT2_TK_ROTATE_LEFT },
  { "rotate_right", SMT2_TK_ROTATE_RIGHT },
  { "bvult", SMT2_TK_BVULT },
  { "bvule", SMT2_TK_BVULE },
  { "bvugt", SMT2_TK_BVUGT },
  { "bvuge", SMT2_TK_BVUGE },
  { "bvslt", SMT2_TK_BVSLT },
  { "bvsle", SMT2_TK_BVSLE },
  { "bvsgt", SMT2_TK_BVSGT },
  { "bvsge", SMT2_TK_BVSGE },

  // end marker
  { NULL, 0},
};


/*
 * Table for conversion from token to string
 */
static char *smt2_token_string[NUM_SMT2_TOKENS];


/*
 * Initialize the token-to-string table.
 */
static void init_smt2token2string(void) {
  keyword_t *kw;

  kw = smt2_keywords;
  while (kw->word != NULL) {
    assert(0 <= kw->tk && kw->tk < NUM_SMT2_TOKENS);
    smt2_token_string[kw->tk] = kw->word;
    kw ++;
  }

  smt2_token_string[SMT2_TK_LP] = "(";
  smt2_token_string[SMT2_TK_RP] = ")";
  smt2_token_string[SMT2_TK_EOS] = "<end-of-stream>";
  smt2_token_string[SMT2_TK_NUMERAL] = "<numeral>";
  smt2_token_string[SMT2_TK_DECIMAL] = "<decimal>";
  smt2_token_string[SMT2_TK_HEXADECIMAL] = "<hexadecimal>";
  smt2_token_string[SMT2_TK_BINARY] = "<binary>";
  smt2_token_string[SMT2_TK_STRING] = "<string>";
  smt2_token_string[SMT2_TK_SYMBOL] = "<symbol>";
  smt2_token_string[SMT2_TK_KEYWORD] = "<keyword>";
  smt2_token_string[SMT2_TK_BV_CONSTANT] = "<bv-constant>";

  // errors
  smt2_token_string[SMT2_TK_INVALID_STRING] = "<bad-string>";
  smt2_token_string[SMT2_TK_INVALID_NUMERAL] = "<invalid-numeral>";
  smt2_token_string[SMT2_TK_INVALID_DECIMAL] = "<invalid-decimal>";
  smt2_token_string[SMT2_TK_INVALID_HEXADECIMAL] = "<invalid-hexadecimal>";
  smt2_token_string[SMT2_TK_INVALID_BINARY] = "<invalid-binary>";
  smt2_token_string[SMT2_TK_INVALID_SYMBOL] = "<invalid-symbol>";
  smt2_token_string[SMT2_TK_INVALID_KEYWORD] = "<invalid-keyword>";
  smt2_token_string[SMT2_TK_INVALID_BV_CONSTANT] = "<invalid-bv-constant>";
  smt2_token_string[SMT2_TK_ERROR] = "<error>";
}



/*
 * ACTIVE/INACTIVE TOKENS
 */

/*
 * Depending on the smt-logic, some keywords are interpreted as
 * built-in operators. If they are inactive, they are just interpreted
 * as ordinary symbols. We control which keywords are active using
 * array active_token.
 *
 * As of 2011, the following logics/theories/type names are used:
 *
 *   AUFLIA         Int_ArraysEx                      Int Array
 *   AUFLIRA        Int_Int_Real_Array_ArraysEx       Int Real Array1 Array2
 *   AUFNIRA        Int_Int_Real_Array_ArraysEx       Int Real Array1 Array2
 *   LRA            Reals
 *   QF_AUFBV       BitVector_ArraysEx                Array BitVec
 *   QF_AUFLIA      Int_ArraysEx                      Int Array
 *   QF_AX          ArraysEx                          Array Index Element
 *   QF_BV          Fixed_Size_BitVectors             BitVec
 *   QF_IDL         Ints
 *   QF_LIA         Ints
 *   QF_LRA         Reals
 *   QF_NIA         Ints
 *   QF_NRA         Reals    (added July 2011)
 *   QF_RDL         Reals
 *   QF_UF          Empty
 *   QF_UFIDL       Ints 
 *   QF_UFBV        Fixed_Size_BitVectors             BitVec
 *   QF_UFLIA       Ints
 *   QF_UFLRA       Reals
 *   QF_UFNRA       Reals
 *   UFLRA          Reals    (added July 2011)
 *   UFNIA          Ints
 */
static uint8_t active_token[NUM_SMT2_TOKENS];

/*
 * Activate all default symbols:
 * - all reserved words
 * - all command names
 * - all symbols in the core theory
 */
static void smt2_activate_default(void) {
  uint32_t i;

  for (i=0; i<NUM_SMT2_TOKENS; i++) {
    active_token[i] = false;
  }

  active_token[SMT2_TK_PAR] = true;
  active_token[SMT2_TK_NUM] = true;
  active_token[SMT2_TK_DEC] = true;
  active_token[SMT2_TK_STR] = true;
  active_token[SMT2_TK_UNDERSCORE] = true;
  active_token[SMT2_TK_BANG] = true;
  active_token[SMT2_TK_AS] = true;
  active_token[SMT2_TK_LET] = true;
  active_token[SMT2_TK_EXISTS] = true;
  active_token[SMT2_TK_FORALL] = true;

  active_token[SMT2_TK_ASSERT] = true;
  active_token[SMT2_TK_CHECK_SAT] = true;
  active_token[SMT2_TK_DECLARE_SORT] = true;
  active_token[SMT2_TK_DECLARE_FUN] = true;
  active_token[SMT2_TK_DEFINE_SORT] = true;
  active_token[SMT2_TK_DEFINE_FUN] = true;
  active_token[SMT2_TK_EXIT] = true;
  active_token[SMT2_TK_GET_ASSERTIONS] = true;
  active_token[SMT2_TK_GET_ASSIGNMENT] = true;
  active_token[SMT2_TK_GET_INFO] = true;
  active_token[SMT2_TK_GET_OPTION] = true;
  active_token[SMT2_TK_GET_PROOF] = true;
  active_token[SMT2_TK_GET_UNSAT_CORE] = true;
  active_token[SMT2_TK_GET_VALUE] = true;
  active_token[SMT2_TK_POP] = true;
  active_token[SMT2_TK_PUSH] = true;
  active_token[SMT2_TK_SET_LOGIC] = true;
  active_token[SMT2_TK_SET_INFO] = true;
  active_token[SMT2_TK_SET_OPTION] = true;

  active_token[SMT2_TK_BOOL] = true;
  active_token[SMT2_TK_TRUE] = true;
  active_token[SMT2_TK_FALSE] = true;
  active_token[SMT2_TK_NOT] = true;
  active_token[SMT2_TK_IMPLIES] = true;
  active_token[SMT2_TK_AND] = true;
  active_token[SMT2_TK_OR] = true;
  active_token[SMT2_TK_XOR] = true;
  active_token[SMT2_TK_EQ] = true;
  active_token[SMT2_TK_DISTINCT] = true;
  active_token[SMT2_TK_ITE] = true;
}


/*
 * Arrays (theory ArraysEx)
 */
static void smt2_activate_arrays(void) {
  active_token[SMT2_TK_ARRAY] = true;
  active_token[SMT2_TK_SELECT] = true;
  active_token[SMT2_TK_STORE] = true;
}


/*
 * Integer arithmetic (theory Ints)
 */
static void smt2_activate_ints(void) {
  active_token[SMT2_TK_INT] = true;
  active_token[SMT2_TK_MINUS] = true;
  active_token[SMT2_TK_PLUS] = true;
  active_token[SMT2_TK_TIMES] = true;
  active_token[SMT2_TK_LE] = true;
  active_token[SMT2_TK_LT] = true;
  active_token[SMT2_TK_GE] = true;
  active_token[SMT2_TK_GT] = true;
  active_token[SMT2_TK_DIV] = true;
  active_token[SMT2_TK_MOD] = true;
  active_token[SMT2_TK_ABS] = true;
  active_token[SMT2_TK_DIVISIBLE] = true;
}


/*
 * Real arithmetic (theory Reals)
 */
static void smt2_activate_reals(void) {
  active_token[SMT2_TK_REAL] = true;
  active_token[SMT2_TK_MINUS] = true;
  active_token[SMT2_TK_PLUS] = true;
  active_token[SMT2_TK_TIMES] = true;
  active_token[SMT2_TK_DIVIDES] = true;
  active_token[SMT2_TK_LE] = true;
  active_token[SMT2_TK_LT] = true;
  active_token[SMT2_TK_GE] = true;
  active_token[SMT2_TK_GT] = true;
}


/*
 * All symbols in Reals_Ints
 */
static void smt2_activate_mixed_arith(void) {
  smt2_activate_ints();
  smt2_activate_reals();
  active_token[SMT2_TK_TO_REAL] = true;
  active_token[SMT2_TK_TO_INT] = true;
  active_token[SMT2_TK_IS_INT] = true;
}


/*
 * All bitvector symbols + the bv-constant token
 * - we don't activate bvredor and bvredand since they are not officially
 *   in SMT-LIB 2.0
 */
static void smt2_activate_bv(void) {
  active_token[SMT2_TK_BV_CONSTANT] = true;
  active_token[SMT2_TK_BITVEC] = true;
  active_token[SMT2_TK_CONCAT] = true;
  active_token[SMT2_TK_EXTRACT] = true;
  active_token[SMT2_TK_REPEAT] = true;
  active_token[SMT2_TK_BVCOMP] = true;
  active_token[SMT2_TK_BVNOT] = true;
  active_token[SMT2_TK_BVAND] = true;
  active_token[SMT2_TK_BVOR] = true;
  active_token[SMT2_TK_BVNAND] = true;
  active_token[SMT2_TK_BVNOR] = true;
  active_token[SMT2_TK_BVXOR] = true;
  active_token[SMT2_TK_BVXNOR] = true;
  active_token[SMT2_TK_BVNEG] = true;
  active_token[SMT2_TK_BVADD] = true;
  active_token[SMT2_TK_BVSUB] = true;
  active_token[SMT2_TK_BVMUL] = true;
  active_token[SMT2_TK_BVUDIV] = true;
  active_token[SMT2_TK_BVUREM] = true;
  active_token[SMT2_TK_BVSDIV] = true;
  active_token[SMT2_TK_BVSREM] = true;
  active_token[SMT2_TK_BVSMOD] = true;
  active_token[SMT2_TK_BVSHL] = true;
  active_token[SMT2_TK_BVLSHR] = true;
  active_token[SMT2_TK_BVASHR] = true;
  active_token[SMT2_TK_ZERO_EXTEND] = true;
  active_token[SMT2_TK_SIGN_EXTEND] = true;
  active_token[SMT2_TK_ROTATE_LEFT] = true;
  active_token[SMT2_TK_ROTATE_RIGHT] = true;
  active_token[SMT2_TK_BVULT] = true;
  active_token[SMT2_TK_BVULE] = true;
  active_token[SMT2_TK_BVUGT] = true;
  active_token[SMT2_TK_BVUGE] = true;
  active_token[SMT2_TK_BVSLT] = true;
  active_token[SMT2_TK_BVSLE] = true;
  active_token[SMT2_TK_BVSGT] = true;
  active_token[SMT2_TK_BVSGE] = true;
}


/*
 * Select the built-in symbols for a given logic
 */
void smt2_lexer_activate_logic(smt_logic_t logic) {
  switch (logic) {
  case AUFLIA:
  case QF_AUFLIA:
    smt2_activate_ints();
    smt2_activate_arrays();
    break;

  case AUFLIRA:
  case AUFNIRA:
    smt2_activate_mixed_arith();
    smt2_activate_arrays();
    break;

  case LRA:
  case QF_LRA:
  case QF_NRA:
  case QF_RDL:
  case QF_UFLRA:
  case QF_UFNRA:
  case UFLRA:
    smt2_activate_reals();
    break;

  case QF_ABV:
  case QF_AUFBV:
    smt2_activate_bv();
    smt2_activate_arrays();
    break;

  case QF_AX:
    smt2_activate_arrays();
    break;

  case QF_BV:
  case QF_UFBV:
    smt2_activate_bv();
    break;

  case QF_IDL:
  case QF_LIA:
  case QF_NIA:
  case QF_UFIDL:
  case QF_UFLIA:
  case UFNIA:
    smt2_activate_ints();
    break;

  case QF_UF:
  case SMT_UNKNOWN:
    break;
  }
}


/*
 * Lexer initialization
 */
int32_t init_smt2_file_lexer(lexer_t *lex, char *filename) {
  init_smt2token2string();
  smt2_activate_default();
  return init_file_lexer(lex, filename);
}

void init_smt2_stream_lexer(lexer_t *lex, FILE *f, char *name) {
  init_smt2token2string();
  smt2_activate_default();
  init_stream_lexer(lex, f, name);
}

void init_smt2_string_lexer(lexer_t *lex, char *data, char *name) {
  init_smt2token2string();
  smt2_activate_default();
  init_string_lexer(lex, data, name);
}


/*
 * Get string for token tk
 */
char *smt2_token_to_string(smt2_token_t tk) {
  assert(0 <= tk && tk < NUM_SMT2_TOKENS);
  return smt2_token_string[tk];
}


/*
 * Read a string literal
 * - current char is "
 * - read all characters until the closing " or any non-printable 
 *   character
 * - replace escape sequences \" by " and \\ by \
 *
 * Result: the lexer's buffer contains the string literal
 * without the delimiting quotes.
 * - return code:
 *   SMT2_TK_STRING if the string is valid
 *   SMT2_TK_INVALID_STRING if the string is terminated by 
 *   a non-printable characeter
 *
 * NOTE: this is not strictly compliant with the SMT-LIB 2.0
 * standard as we may include non-ascii printable characters
 * in the string.
 */
static smt2_token_t smt2_read_string(lexer_t *lex) {
  reader_t *rd;
  string_buffer_t *buffer;
  int c;
  smt2_token_t tk;

  rd = &lex->reader;
  buffer = lex->buffer;
  assert(reader_current_char(rd) == '"');

  for (;;) {
    c = reader_next_char(rd);
    if (c == '"') {
      // consume the closing quote
      reader_next_char(rd);
      tk = SMT2_TK_STRING;
      break;
    }

    if (! isprint(c)) {
      // error
      tk = SMT2_TK_INVALID_STRING;
      break;
    }

    if (c == '\\') {
      c = reader_next_char(rd);
      if (c != '"' && c != '\\') {
	// keep the backslash
	string_buffer_append_char(buffer, '\\');
      }
    }
    string_buffer_append_char(buffer, c);
  }

  string_buffer_close(buffer);

  return tk;
}


/*
 * Read a binary literal
 * - the buffer must contain '#'
 * - current char must be 'b'
 * - add 'b' and the sequence of '0' and '1' that follows 
 *   to the buffer
 * - stop on the first character that's not '0' or '1'
 *
 * The resulting token is stored in buffer
 * - return code: 
 *   SMT2_TK_BINARY if the sequence is non-empty
 *   SMT2_TK_INVALID_BINARY if the sequence is empty
 */
static smt2_token_t smt2_read_binary(lexer_t *lex) {
  reader_t *rd;
  string_buffer_t *buffer;
  int c;
  smt2_token_t tk;

  rd = &lex->reader;
  buffer = lex->buffer;
  c = reader_current_char(rd);

  assert(string_buffer_length(buffer) == 1 && 
	 buffer->data[0] == '#' && c == 'b');

  do {
    string_buffer_append_char(buffer, c);
    c = reader_next_char(rd);
  } while (c == '0' || c == '1');
  string_buffer_close(buffer);

  tk = SMT2_TK_BINARY;
  if (string_buffer_length(buffer) <= 2) {
    tk = SMT2_TK_INVALID_BINARY;
  }

  return tk;
}


/*
 * Read an hexadecimal literal
 * - the buffer must contain '#'
 * - current_char must be 'x'
 * - add 'x' and the sequence of hexadecimal digits that 
 *   follows to the buffer
 * - stop on the first character that's not hexadecimal
 *
 * The resulting token is stored in buffer
 * - return code: 
 *   SMT2_TK_HEXADECIMAL if the sequence is non-empty
 *   SMT2_TK_INVALID_HEXADECIMAL if the sequence is empty
 */
static smt2_token_t smt2_read_hexa(lexer_t *lex) {
  reader_t *rd;
  string_buffer_t *buffer;
  int c;
  smt2_token_t tk;

  rd = &lex->reader;
  buffer = lex->buffer;
  c = reader_current_char(rd);

  assert(string_buffer_length(buffer) == 1 && 
	 buffer->data[0] == '#' && c == 'x');

  do {
    string_buffer_append_char(buffer, c);
    c = reader_next_char(rd);
  } while (isxdigit(c));
  string_buffer_close(buffer);

  tk = SMT2_TK_HEXADECIMAL;
  if (string_buffer_length(buffer) <= 2) {
    tk = SMT2_TK_INVALID_HEXADECIMAL;
  }

  return tk;
}


/*
 * Numbers that don't start with '0'
 * - the buffer must be empty
 * - current char must be a digit '1' to '9'
 * - read the sequence of digits that follows and add it to the buffer
 * - if the character after this sequence is '.' then read as a DECIMAL
 *   otherwise the token is a NUMERAL.
 *
 * Return code:
 * - SMT2_INVALID_DECIMAL if the '.' is not followed by a digit
 */
static smt2_token_t smt2_read_number(lexer_t *lex) {
  reader_t *rd;
  string_buffer_t *buffer;  
  int c;
  smt2_token_t tk;
  uint32_t i;

  rd = &lex->reader;
  buffer = lex->buffer;
  c = reader_current_char(rd);

  assert(string_buffer_length(buffer) == 0 && isdigit(c) && c != '0');

  // first sequence of digits
  do {
    string_buffer_append_char(buffer, c);
    c = reader_next_char(rd);
  } while (isdigit(c));

  tk = SMT2_TK_NUMERAL;
  if (c == '.') {
    i = string_buffer_length(buffer);

    // attempt to parse a DECIMAL
    do {
      string_buffer_append_char(buffer, c);
      c = reader_next_char(rd);
    } while (isdigit(c));

    tk = SMT2_TK_DECIMAL;
    if (string_buffer_length(buffer) <= i+1) {
      tk = SMT2_TK_INVALID_DECIMAL;
    }
  }

  string_buffer_close(buffer);

  return tk;
}


/*
 * Numbers that start with '0'
 * - the buffer must be empty
 * - current char must be '0'
 */
static smt2_token_t smt2_read_number0(lexer_t *lex) {
  reader_t *rd;
  string_buffer_t *buffer;
  int c;
  smt2_token_t tk;

  rd = &lex->reader;
  buffer = lex->buffer;
  c = reader_current_char(rd);

  assert(string_buffer_length(buffer) == 0 && c == '0');

  // add '0'
  string_buffer_append_char(buffer, c);
  
  c = reader_next_char(rd);
  tk = SMT2_TK_NUMERAL;

  if (c == '.') {
    // parse a decimal '0.<digits>'
    do {
      string_buffer_append_char(buffer, c);
      c = reader_next_char(rd);
    } while (isdigit(c));

    tk = SMT2_TK_DECIMAL;
    if (string_buffer_length(buffer) <= 2) {
      tk = SMT2_TK_INVALID_DECIMAL; // '0.' but not digit after that
    }

  } else if (isdigit(c)) {
    /*
     * invalid numeral such as '00..' or '05...'
     * put all the digits that follow '0' in the buffer
     * to give a nicer error message
     */
    do {
      string_buffer_append_char(buffer, c);
      c = reader_next_char(rd);
    } while (isdigit(c));

    tk = SMT2_TK_INVALID_NUMERAL;
  }

  string_buffer_close(buffer);
  
  return tk;
}



/*
 * Check whether the content of buffer is of the form 
 *  'bv' + a sequence of digits
 * - i.e., buffer encodes a bit-vector constant
 */
static bool is_bv_constant(string_buffer_t *buffer) {
  uint32_t i, n;

  n = string_buffer_length(buffer);
  if (n >= 3 && buffer->data[0] == 'b' && buffer->data[1] == 'v') {
    for (i=2; i<n; i++) {
      if (!isdigit(buffer->data[i])) {
	return false;
      }
    }
    return true;
  }

  return false;
}


/*
 * Get the token ID for the content of the buffer:
 * - if the buffer is in the symbol table and the symbol is active
 *   return the corresponding token ID
 * - if the buffer contains 'bv<digits>' and the BV_CONSTANT is
 *   active, return SMT2_TK_BV_CONSTANT
 * - otherwise, return SMT2_TK_SYMBOL
 */
static smt2_token_t smt2_symbol_type(string_buffer_t *buffer) {
  const keyword_t *kw;
  smt2_token_t tk;

  tk = SMT2_TK_SYMBOL;
  kw = in_smt2_kw(buffer->data, buffer->index);
  if (kw == NULL) {
    // not in the symbol table
    if (active_token[SMT2_TK_BV_CONSTANT] && is_bv_constant(buffer)) {
      tk = SMT2_TK_BV_CONSTANT;
    }
  } else if (active_token[kw->tk]) {
    // active symbol
    tk = kw->tk;
  }

  return tk;
}


/*
 * Characters that may appear in keywords and simple symbols:
 * - digits + letters + ~ ! @ $ % ^ & * _ - + = < > . ? /
 *
 * NOTE: again, we don't really follow the standard (we can
 * accept non-ASCII characters, depending on the locale and 
 * how isalnum(c) decides).
 */
static bool issimple(int c) {
  if (isalnum(c)) {
    return true;
  }

  switch (c) {
  case '~':
  case '!':
  case '@':
  case '$':
  case '%':
  case '^':
  case '&':
  case '*':
  case '_':
  case '-':
  case '+':
  case '=':
  case '<':
  case '>':
  case '.':
  case '?':
  case '/':
    return true;

  default:
    return false;
  }
}


/*
 * Read a keyword:
 * - the buffer must be empty
 * - current_char must be ':'
 * - add ':' + the sequence of simple_chars that follows to the buffer
 *
 * If ':' is not followed by a simple char, return SMT2_TK_INVALID_KEYWORD
 * Otherwise return SMT2_TK_KEYWORD
 */
static smt2_token_t smt2_read_keyword(lexer_t *lex) {
  reader_t *rd;
  string_buffer_t *buffer;
  int c;
  smt2_token_t tk;

  rd = &lex->reader;
  buffer = lex->buffer;
  c = reader_current_char(rd);

  assert(string_buffer_length(buffer) == 0 && c == ':');

  do {
    string_buffer_append_char(buffer, c);
    c = reader_next_char(rd);
  } while (issimple(c));
  string_buffer_close(buffer);
  
  tk = SMT2_TK_KEYWORD;
  if (string_buffer_length(buffer) <= 1) {
    tk = SMT2_TK_INVALID_KEYWORD;
  }

  return tk;    
}



/*
 * Read a simple symbol
 * - the buffer must be empty
 * - current_char must be simple
 * - read the sequence of simple chars and add it to the buffer
 */
static smt2_token_t smt2_read_symbol(lexer_t *lex) {
  reader_t *rd;
  string_buffer_t *buffer;
  int c;

  rd = &lex->reader;
  buffer = lex->buffer;
  c = reader_current_char(rd);

  assert(string_buffer_length(buffer) == 0 && issimple(c));

  do {
    string_buffer_append_char(buffer, c);
    c = reader_next_char(rd);
  } while (issimple(c));
  string_buffer_close(buffer);

  return smt2_symbol_type(buffer);
}



/*
 * Read a quoted symbol: any sequence of characters delimited by '|'
 * - exceptions: no '\' allowed in the symbol
 * - all characters between '|' must be printable
 * - the delimiting '|' are not part of the symbol
 *
 * - the buffer must be empty
 * - current char must be '|'
 */
static smt2_token_t smt2_read_quoted_symbol(lexer_t *lex) {
  reader_t *rd;
  string_buffer_t *buffer;
  int c;
  smt2_token_t tk;

  rd = &lex->reader;
  buffer = lex->buffer;
  assert(string_buffer_length(buffer) == 0 &&
	 reader_current_char(rd) == '|');

  for (;;) {
    c = reader_next_char(rd);
    if (c == '|' || c == '\\' || 
	(!isprint(c) && !isspace(c))) {
      // either the terminator '|' or a character not allowed in quoted symbols
      break;
    }
    string_buffer_append_char(buffer, c);    
  }
  string_buffer_close(buffer);

  tk = SMT2_TK_INVALID_SYMBOL;
  if (c == '|') {
    // consume the closing '|' then convert to the right type
    reader_next_char(rd);
    tk = smt2_symbol_type(buffer);
  }
  
  return tk;
}


/*
 * Read the next token and return its code tk
 * - set lex->token to tk
 * - set lex->tk_pos ect
 * - if the token is not '(' or ')', then its value is in lex->buffer
 *   as a string
 */
smt2_token_t next_smt2_token(lexer_t *lex) {
  reader_t *rd;
  string_buffer_t *buffer;
  int c;
  smt2_token_t tk;

  rd = &lex->reader;
  c = reader_current_char(rd);
  buffer = lex->buffer;
  string_buffer_reset(buffer);

  // skip spaces and comments
  for (;;) {
    while (isspace(c)) c = reader_next_char(rd);
    if (c != ';') break;
    // comments: read everything until the end of the line or EOF
    do {
      c= reader_next_char(rd);;
    } while (c != '\n' && c != EOF);
  }

  // record start of token
  lex->tk_pos = rd->pos;
  lex->tk_line = rd->line;
  lex->tk_column = rd->column;

  switch (c) {
  case '(':
    tk = SMT2_TK_LP;
    goto next_then_return;

  case ')':
    tk = SMT2_TK_RP;
    goto next_then_return;

  case EOF:
    tk = SMT2_TK_EOS;
    goto done;

  case '"':
    tk = smt2_read_string(lex);
    goto done;

  case '#':
    string_buffer_append_char(buffer, c);
    c = reader_next_char(rd);
    if (c == 'b') {
      tk = smt2_read_binary(lex);
    } else if (c == 'x') {
      tk = smt2_read_hexa(lex);
    } else {
      tk = SMT2_TK_ERROR;
      string_buffer_close(buffer);      
    }
    goto done;

  case '0':
    tk = smt2_read_number0(lex);
    goto done;

  case '1':
  case '2':
  case '3':
  case '4': 
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':
    tk = smt2_read_number(lex);
    goto done;

  case ':':
    tk = smt2_read_keyword(lex);
    goto done;

  case '|':
    tk = smt2_read_quoted_symbol(lex);
    goto done;

  default:
    if (issimple(c)) {
      tk = smt2_read_symbol(lex);
      goto done;
    } else {
      tk = SMT2_TK_ERROR;
      goto next_then_return;
    }
  }

 next_then_return:
  reader_next_char(rd);

 done:
  lex->token = tk;

  return tk;
}
