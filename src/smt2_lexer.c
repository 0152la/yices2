/*
 * Lexer for the SMT-LIB language (version 2)
 */

#include <assert.h>

/*
 * smt2_hash_keywords.h is generated by gperf from smt2_keywords.txt
 */

#include "smt2_lexer.h"
#include "smt2_hash_keywords.h"


/*
 * All predefined symbols
 */
static keyword_t smt2_keywords[] = {
  // reserved words
  { "par", SMT2_TK_PAR },
  { "NUMERAL", SMT2_TK_NUM },
  { "DECIMAL", SMT2_TK_DEC },
  { "STRING", SMT2_TK_STR },
  { "_", SMT2_TK_UNDERSCORE },
  { "!", SMT2_TK_BANG },
  { "as", SMT2_TK_AS },
  { "let", SMT2_TK_LET },
  { "exists", SMT2_TK_EXISTS },
  { "forall", SMT2_TK_FORALL },
  // commands
  { "assert", SMT2_TK_ASSERT },
  { "check-sat", SMT2_TK_CHECK_SAT },
  { "declare-sort", SMT2_TK_DECLARE_SORT },
  { "declare-fun", SMT2_TK_DECLARE_FUN },
  { "define-sort", SMT2_TK_DEFINE_SORT },
  { "define-fun", SMT2_TK_DEFINE_FUN },
  { "exit", SMT2_TK_EXIT },
  { "get-assertions", SMT2_TK_GET_ASSERTIONS },
  { "get-assignmnet", SMT2_TK_GET_ASSIGNMENT },
  { "get-info", SMT2_TK_GET_INFO },
  { "get-option", SMT2_TK_GET_OPTION },
  { "get-proof", SMT2_TK_GET_PROOF },
  { "get-unsat-core", SMT2_TK_GET_UNSAT_CORE },
  { "get-value", SMT2_TK_GET_VALUE },
  { "pop", SMT2_TK_POP },
  { "push", SMT2_TK_PUSH },
  { "set-logic", SMT2_TK_SET_LOGIC },
  { "set-info", SMT2_TK_SET_INFO },
  { "set-option", SMT2_TK_SET_OPTION },
  // Core theory symbols
  { "Bool", SMT2_TK_BOOL },
  { "true", SMT2_TK_TRUE },
  { "false", SMT2_TK_FALSE },
  { "not", SMT2_TK_NOT },
  { "=>", SMT2_TK_IMPLIES },
  { "and", SMT2_TK_AND },
  { "or", SMT2_TK_OR },
  { "xor", SMT2_TK_XOR },
  { "=", SMT2_TK_EQ },
  { "distinct", SMT2_TK_DISTINCT },
  { "ite", SMT2_TK_ITE },
  // Arrays
  { "Array", SMT2_TK_ARRAY },
  { "select", SMT2_TK_SELECT },
  { "store", SMT2_TK_STORE },
  // Arithmetic
  { "Int", SMT2_TK_INT },
  { "Real", SMT2_TK_REAL },
  { "-", SMT2_TK_MINUS },
  { "+", SMT2_TK_PLUS },
  { "*", SMT2_TK_TIMES },
  { "/", SMT2_TK_DIVIDES },
  { "<=", SMT2_TK_LE },
  { "<", SMT2_TK_LT },
  { ">=", SMT2_TK_GE },
  { ">", SMT2_TK_GT },
  { "div", SMT2_TK_DIV },
  { "mod", SMT2_TK_MOD },
  { "abs", SMT2_TK_ABS },
  { "to_real", SMT2_TK_TO_REAL },
  { "to_int", SMT2_TK_TO_INT },
  { "is_int", SMT2_TK_IS_INT },
  { "divisible", SMT2_TK_DIVISIBLE },
  // Bitvectors
  { "BitVec", SMT2_TK_BITVEC },
  { "concat", SMT2_TK_CONCAT },
  { "extract", SMT2_TK_EXTRACT },
  { "repeat", SMT2_TK_REPEAT },
  { "bvcomp", SMT2_TK_BVCOMP },
  { "bvnot", SMT2_TK_BVNOT },
  { "bvand", SMT2_TK_BVAND },
  { "bvor", SMT2_TK_BVOR },
  { "bvnand", SMT2_TK_BVNAND },
  { "bvnor", SMT2_TK_BVNOR },
  { "bvxor", SMT2_TK_BVXOR },
  { "bvxnor", SMT2_TK_BVXNOR },
  { "bvneg", SMT2_TK_BVNEG },
  { "bvadd", SMT2_TK_BVADD },
  { "bvsub", SMT2_TK_BVSUB },
  { "bvmul", SMT2_TK_BVMUL },
  { "bvudiv", SMT2_TK_BVUDIV },
  { "bvurem", SMT2_TK_BVUREM },
  { "bvsdiv", SMT2_TK_BVSDIV },
  { "bvsrem", SMT2_TK_BVSREM },
  { "bvsmod", SMT2_TK_BVSMOD },
  { "bvshl", SMT2_TK_BVSHL },
  { "bvlshr", SMT2_TK_BVLSHR },
  { "bvashr", SMT2_TK_BVASHR },
  { "zero_extend", SMT2_TK_ZERO_EXTEND },
  { "sign_extend", SMT2_TK_SIGN_EXTEND },
  { "rotate_left", SMT2_TK_ROTATE_LEFT },
  { "rotate_right", SMT2_TK_ROTATE_RIGHT },
  { "bvult", SMT2_TK_BVULT },
  { "bvule", SMT2_TK_BVULE },
  { "bvugt", SMT2_TK_BVUGT },
  { "bvuge", SMT2_TK_BVUGE },
  { "bvslt", SMT2_TK_BVSLT },
  { "bvsle", SMT2_TK_BVSLE },
  { "bvsgt", SMT2_TK_BVSGT },
  { "bvsge", SMT2_TK_BVSGE },

  // end marker
  { NULL, 0},
};


/*
 * Table for conversion from token to string
 */
static char *smt2_token_string[NUM_SMT2_TOKENS];


/*
 * Initialize the token-to-string table.
 */
static void init_smt2token2string(void) {
  keyword_t *kw;

  kw = smt2_keywords;
  while (kw->word != NULL) {
    assert(0 <= kw->tk && kw->tk < NUM_SMT2_TOKENS);
    smt2_token_string[kw->tk] = kw->word;
    kw ++;
  }

  smt2_token_string[SMT2_TK_LP] = "(";
  smt2_token_string[SMT2_TK_RP] = ")";
  smt2_token_string[SMT2_TK_EOS] = "<end-of-stream>";
  smt2_token_string[SMT2_TK_NUMERAL] = "<numeral>";
  smt2_token_string[SMT2_TK_DECIMAL] = "<decimal>";
  smt2_token_string[SMT2_TK_HEXADECIMAL] = "<hexadecimal>";
  smt2_token_string[SMT2_TK_BINARY] = "<binary>";
  smt2_token_string[SMT2_TK_STRING] = "<string>";
  smt2_token_string[SMT2_TK_SYMBOL] = "<symbol>";
  smt2_token_string[SMT2_TK_KEYWORD] = "<keyword>";
  smt2_token_string[SMT2_TK_BV_CONSTANT] = "<bv-constant>";

  // errors
  smt2_token_string[SMT2_TK_OPEN_STRING] = "<bad-string>";
  smt2_token_string[SMT2_TK_INVALID_NUMERAL] = "<invalid-numeral>";
  smt2_token_string[SMT2_TK_INVALID_DECIMAL] = "<invalid-decimal>";
  smt2_token_string[SMT2_TK_INVALID_HEXADECIMAL] = "<invalid-hexadecimal>";
  smt2_token_string[SMT2_TK_INVALID_BINARY] = "<invalid-binary>";
  smt2_token_string[SMT2_TK_INVALID_KEYWORD] = "<invalid-keyword>";
  smt2_token_string[SMT2_TK_INVALID_BV_CONSTANT] = "<invalid-bv-constant>";
  smt2_token_string[SMT2_TK_ERROR] = "<error>";
}



/*
 * ACTIVE/INACTIVE TOKENS
 */

/*
 * Depending on the smt-logic, some keywords are interpreted as
 * built-in operators. If they are inactive, they are just interpreted
 * as ordinary symbols. We control which keywords are active using
 * array active_token.
 *
 * As of 2011, the following logics/theories/type names are used:
 *
 *   AUFLIA         Int_ArraysEx                      Int Array
 *   AUFLIRA        Int_Int_Real_Array_ArraysEx       Int Real Array1 Array2
 *   AUFNIRA        Int_Int_Real_Array_ArraysEx       Int Real Array1 Array2
 *   LRA            Reals
 *   QF_AUFBV       BitVector_ArraysEx                Array BitVec
 *   QF_AUFLIA      Int_ArraysEx                      Int Array
 *   QF_AX          ArraysEx                          Array Index Element
 *   QF_BV          Fixed_Size_BitVectors             BitVec
 *   QF_IDL         Ints
 *   QF_LIA         Ints
 *   QF_LRA         Reals
 *   QF_NIA         Ints
 *   QF_NRA         Reals    (added July 2011)
 *   QF_RDL         Reals
 *   QF_UF          Empty
 *   QF_UFIDL       Ints 
 *   QF_UFBV        Fixed_Size_BitVectors             BitVec
 *   QF_UFLIA       Ints
 *   QF_UFLRA       Reals
 *   QF_UFNRA       Reals
 *   UFLRA          Reals    (added July 2011)
 *   UFNIA          Ints
 */
static uint8_t active_token[NUM_SMT2_TOKENS];

/*
 * Activate all default symbols:
 * - all reserved words
 * - all command names
 * - all symbols in the core theory
 */
static void smt2_activate_default(void) {
  uint32_t i;

  for (i=0; i<NUM_SMT2_TOKENS; i++) {
    active_token[i] = false;
  }

  active_token[SMT2_TK_PAR] = true;
  active_token[SMT2_TK_NUM] = true;
  active_token[SMT2_TK_DEC] = true;
  active_token[SMT2_TK_STR] = true;
  active_token[SMT2_TK_UNDERSCORE] = true;
  active_token[SMT2_TK_BANG] = true;
  active_token[SMT2_TK_AS] = true;
  active_token[SMT2_TK_LET] = true;
  active_token[SMT2_TK_EXISTS] = true;
  active_token[SMT2_TK_FORALL] = true;

  active_token[SMT2_TK_ASSERT] = true;
  active_token[SMT2_TK_CHECK_SAT] = true;
  active_token[SMT2_TK_DECLARE_SORT] = true;
  active_token[SMT2_TK_DECLARE_FUN] = true;
  active_token[SMT2_TK_DEFINE_SORT] = true;
  active_token[SMT2_TK_DEFINE_FUN] = true;
  active_token[SMT2_TK_EXIT] = true;
  active_token[SMT2_TK_GET_ASSERTIONS] = true;
  active_token[SMT2_TK_GET_ASSIGNMENT] = true;
  active_token[SMT2_TK_GET_INFO] = true;
  active_token[SMT2_TK_GET_OPTION] = true;
  active_token[SMT2_TK_GET_PROOF] = true;
  active_token[SMT2_TK_GET_UNSAT_CORE] = true;
  active_token[SMT2_TK_GET_VALUE] = true;
  active_token[SMT2_TK_POP] = true;
  active_token[SMT2_TK_PUSH] = true;
  active_token[SMT2_TK_SET_LOGIC] = true;
  active_token[SMT2_TK_SET_INFO] = true;
  active_token[SMT2_TK_SET_OPTION] = true;

  active_token[SMT2_TK_BOOL] = true;
  active_token[SMT2_TK_TRUE] = true;
  active_token[SMT2_TK_FALSE] = true;
  active_token[SMT2_TK_NOT] = true;
  active_token[SMT2_TK_IMPLIES] = true;
  active_token[SMT2_TK_AND] = true;
  active_token[SMT2_TK_OR] = true;
  active_token[SMT2_TK_XOR] = true;
  active_token[SMT2_TK_EQ] = true;
  active_token[SMT2_TK_DISTINCT] = true;
  active_token[SMT2_TK_ITE] = true;
}


/*
 * Arrays (theory ArraysEx)
 */
static void smt2_activate_arrays(void) {
  active_token[SMT2_TK_ARRAY] = true;
  active_token[SMT2_TK_SELECT] = true;
  active_token[SMT2_TK_STORE] = true;
}


/*
 * Integer arithmetic (theory Ints)
 */
static void smt2_activate_ints(void) {
  active_token[SMT2_TK_INT] = true;
  active_token[SMT2_TK_MINUS] = true;
  active_token[SMT2_TK_PLUS] = true;
  active_token[SMT2_TK_TIMES] = true;
  active_token[SMT2_TK_LE] = true;
  active_token[SMT2_TK_LT] = true;
  active_token[SMT2_TK_GE] = true;
  active_token[SMT2_TK_GT] = true;
  active_token[SMT2_TK_DIV] = true;
  active_token[SMT2_TK_MOD] = true;
  active_token[SMT2_TK_ABS] = true;
  active_token[SMT2_TK_DIVISIBLE] = true;
}


/*
 * Real arithmetic (theory Reals)
 */
static void smt2_activate_reals(void) {
  active_token[SMT2_TK_REAL] = true;
  active_token[SMT2_TK_MINUS] = true;
  active_token[SMT2_TK_PLUS] = true;
  active_token[SMT2_TK_TIMES] = true;
  active_token[SMT2_TK_DIVIDES] = true;
  active_token[SMT2_TK_LE] = true;
  active_token[SMT2_TK_LT] = true;
  active_token[SMT2_TK_GE] = true;
  active_token[SMT2_TK_GT] = true;
}


/*
 * All symbols in Reals_Ints
 */
static void smt2_activate_mixed_arith(void) {
  smt2_activate_ints();
  smt2_activate_reals();
  active_token[SMT2_TK_TO_REAL] = true;
  active_token[SMT2_TK_TO_INT] = true;
  active_token[SMT2_TK_IS_INT] = true;
}


/*
 * All bitvector symbols + the bv-constant token
 * - we don't activate bvredor and bvredand since they are not officially
 *   in SMT-LIB 2.0
 */
static void smt2_activate_bv(void) {
  active_token[SMT2_TK_BV_CONSTANT] = true;
  active_token[SMT2_TK_BITVEC] = true;
  active_token[SMT2_TK_CONCAT] = true;
  active_token[SMT2_TK_EXTRACT] = true;
  active_token[SMT2_TK_REPEAT] = true;
  active_token[SMT2_TK_BVCOMP] = true;
  active_token[SMT2_TK_BVNOT] = true;
  active_token[SMT2_TK_BVAND] = true;
  active_token[SMT2_TK_BVOR] = true;
  active_token[SMT2_TK_BVNAND] = true;
  active_token[SMT2_TK_BVNOR] = true;
  active_token[SMT2_TK_BVXOR] = true;
  active_token[SMT2_TK_BVXNOR] = true;
  active_token[SMT2_TK_BVNEG] = true;
  active_token[SMT2_TK_BVADD] = true;
  active_token[SMT2_TK_BVSUB] = true;
  active_token[SMT2_TK_BVMUL] = true;
  active_token[SMT2_TK_BVUDIV] = true;
  active_token[SMT2_TK_BVUREM] = true;
  active_token[SMT2_TK_BVSDIV] = true;
  active_token[SMT2_TK_BVSREM] = true;
  active_token[SMT2_TK_BVSMOD] = true;
  active_token[SMT2_TK_BVSHL] = true;
  active_token[SMT2_TK_BVLSHR] = true;
  active_token[SMT2_TK_BVASHR] = true;
  active_token[SMT2_TK_ZERO_EXTEND] = true;
  active_token[SMT2_TK_SIGN_EXTEND] = true;
  active_token[SMT2_TK_ROTATE_LEFT] = true;
  active_token[SMT2_TK_ROTATE_RIGHT] = true;
  active_token[SMT2_TK_BVULT] = true;
  active_token[SMT2_TK_BVULE] = true;
  active_token[SMT2_TK_BVUGT] = true;
  active_token[SMT2_TK_BVUGE] = true;
  active_token[SMT2_TK_BVSLT] = true;
  active_token[SMT2_TK_BVSLE] = true;
  active_token[SMT2_TK_BVSGT] = true;
  active_token[SMT2_TK_BVSGE] = true;
}


/*
 * Select the built-in symbols for a given logic
 */
void smt2_lexer_activate_logic(smt_logic_t logic) {
  switch (logic) {
  case AUFLIA:
  case QF_AUFLIA:
    smt2_activate_ints();
    smt2_activate_arrays();
    break;

  case AUFLIRA:
  case AUFNIRA:
    smt2_activate_mixed_arith();
    smt2_activate_arrays();
    break;

  case LRA:
  case QF_LRA:
  case QF_NRA:
  case QF_RDL:
  case QF_UFLRA:
  case QF_UFNRA:
  case UFLRA:
    smt2_activate_reals();
    break;

  case QF_ABV:
  case QF_AUFBV:
    smt2_activate_bv();
    smt2_activate_arrays();
    break;

  case QF_AX:
    smt2_activate_arrays();
    break;

  case QF_BV:
  case QF_UFBV:
    smt2_activate_bv();
    break;

  case QF_IDL:
  case QF_LIA:
  case QF_NIA:
  case QF_UFIDL:
  case QF_UFLIA:
  case UFNIA:
    smt2_activate_ints();
    break;

  case QF_UF:
  case SMT_UNKNOWN:
    break;
  }
}


/*
 * Lexer initialization
 */
int32_t init_smt2_file_lexer(lexer_t *lex, char *filename) {
  init_smt2token2string();
  smt2_activate_default();
  return init_file_lexer(lex, filename);
}

void init_smt2_stream_lexer(lexer_t *lex, FILE *f, char *name) {
  init_smt2token2string();
  smt2_activate_default();
  init_stream_lexer(lex, f, name);
}

void init_smt2_string_lexer(lexer_t *lex, char *data, char *name) {
  init_smt2token2string();
  smt2_activate_default();
  init_string_lexer(lex, data, name);
}


/*
 * Get string for token tk
 */
char *smt2_token_to_string(smt2_token_t tk) {
  assert(0 <= tk && tk < NUM_SMT2_TOKENS);
  return smt2_token_string[tk];
}
