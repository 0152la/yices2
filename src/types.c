/*
 * Type table and hash consing
 */

#include <string.h>
#include <assert.h>

#include "memalloc.h"
#include "refcount_strings.h"
#include "hash_functions.h"
#include "types.h"


/*
 * Finalizer for typenames in the symbol table.
 * All symbols must be generated by the clone function, and have
 * a reference counter (cf. memalloc.h).
 */
static void typename_finalizer(stbl_rec_t *r) {
  string_decref(r->string);
}


/*
 * Default gc_notifier: do nothing
 */
static void default_gc_notifier(type_table_t *table) {
}


/*
 * Initialize table, with initial size = n.
 */
static void type_table_init(type_table_t *table, uint32_t n) {
  // abort if the size is too large
  if (n >= MAX_TYPES) {
    out_of_memory();
  }

  table->kind = (unsigned char *) safe_malloc(n * sizeof(unsigned char));
  table->desc = (type_desc_t *) safe_malloc(n * sizeof(type_desc_t));
  table->name = (char **) safe_malloc(n * sizeof(char *));
  table->root = allocate_bitvector(n);
  table->size = n;
  table->nelems = 0;
  table->free_idx = NULL_TYPE;
  init_int_htbl(&table->htbl, 32); // use default size
  init_stbl(&table->stbl, 0);     // default size too

  // install finalizer
  stbl_set_finalizer(&table->stbl, typename_finalizer);

  table->gc_mark = NULL;
  table->gc_mark_queue = NULL;
  table->gc_notifier = default_gc_notifier;
}


/*
 * Extend the table: make it 50% larger
 */
static void type_table_extend(type_table_t *table) {
  uint32_t n;

  n = table->size + 1;
  n += n >> 1;

  // force abort in case of numerical overflow.
  if (n <= table->size || n >= MAX_TYPES) {
    out_of_memory(); 
  }

  table->kind = (unsigned char *) safe_realloc(table->kind, n * sizeof(unsigned char));
  table->desc = (type_desc_t *) safe_realloc(table->desc, n * sizeof(type_desc_t));
  table->name = (char **) safe_realloc(table->name, n * sizeof(char *));
  table->root = extend_bitvector(table->root, n);
  table->size = n;
}

/*
 * Get a free type id and initializes its root mark to 0 and its name to NULL.
 */
static type_t allocate_type_id(type_table_t *table) {
  type_t i;

  i = table->free_idx;
  if (i >= 0) {
    table->free_idx = table->desc[i].integer;
  } else {
    i = table->nelems;
    table->nelems ++;
    if (i >= table->size) {
      type_table_extend(table);
    }
  }
  table->name[i] = NULL;
  clr_bit(table->root, i);

  return i;
}

/*
 * Erase type i: free descriptor and recycle i
 */
static void erase_type(type_table_t *table, type_t i) {
  switch (table->kind[i]) {
  case UNUSED_TYPE: // already deleted
  case BOOL_TYPE:
  case INT_TYPE:
  case REAL_TYPE:
    return; // never delete predefined types

  case BITVECTOR_TYPE:
  case SCALAR_TYPE:
  case UNINTERPRETED_TYPE:
    break;

  case TUPLE_TYPE:
  case FUNCTION_TYPE:
    safe_free(table->desc[i].ptr);
    break;
  }

  if (table->name[i] != NULL) {
    string_decref(table->name[i]);
    table->name[i] = NULL;
  }

  table->kind[i] = UNUSED_TYPE;
  table->desc[i].integer = table->free_idx;
  table->free_idx = i;
}


static void add_primitive_types(type_table_t *table) {
  type_t i;

  i = allocate_type_id(table);
  assert(i == bool_id);
  table->kind[i] = BOOL_TYPE;
  table->desc[i].ptr = NULL;

  i = allocate_type_id(table);
  assert(i == int_id);
  table->kind[i] = INT_TYPE;
  table->desc[i].ptr = NULL;

  i = allocate_type_id(table);
  assert(i == real_id);
  table->kind[i] = REAL_TYPE;
  table->desc[i].ptr = NULL;
}




/*
 * Add type (bitvector k) and return its id
 */
static type_t new_bitvector_type(type_table_t *table, int32_t k) {
  type_t i;

  i = allocate_type_id(table);
  table->kind[i] = BITVECTOR_TYPE;
  table->desc[i].integer = k;

  return i;
}


/*
 * Add a scalar type and return its id
 * - k = number of elements in the type 
 * - k must be positive.
 */
type_t new_scalar_type(type_table_t *table, int32_t k) {
  type_t i;

  assert(k > 0);
  i = allocate_type_id(table);
  table->kind[i] = SCALAR_TYPE;
  table->desc[i].integer = k;

  return i;
}


/*
 * Add a new uninterpreted type and return its id
 */
type_t new_uninterpreted_type(type_table_t *table) {
  type_t i;

  i = allocate_type_id(table);
  table->kind[i] = UNINTERPRETED_TYPE;
  table->desc[i].ptr = NULL;

  return i;
}


/*
 * Add tuple type: e[0], ..., e[n-1]
 */
static type_t new_tuple_type(type_table_t *table, int32_t n, type_t *e) {
  type_t i;
  int32_t j;
  tuple_type_t *d;

  d = (tuple_type_t *) safe_malloc(sizeof(tuple_type_t) + n * sizeof(type_t));
  d->nelem = n;
  for (j=0; j<n; j++) d->elem[j] = e[j];

  i = allocate_type_id(table);
  table->kind[i] = TUPLE_TYPE;
  table->desc[i].ptr = d;

  return i;
}

/*
 * Add function type: (e[0], ..., e[n-1] --> r)
 */
static type_t new_function_type(type_table_t *table, int32_t n, type_t *e, type_t r) {
  type_t i;
  int32_t j;
  function_type_t *d;

  d = (function_type_t *) safe_malloc(sizeof(function_type_t) + n * sizeof(type_t));
  d->range = r;
  d->ndom = n;
  for (j=0; j<n; j++) d->domain[j] = e[j];

  i = allocate_type_id(table);
  table->kind[i] = FUNCTION_TYPE;
  table->desc[i].ptr = d;

  return i;
}


/*
 * Objects for hash-consing
 */
typedef struct bv_type_hobj_s {
  int_hobj_t m;      // methods
  type_table_t *tbl;
  int32_t size;
} bv_type_hobj_t;

typedef struct tuple_type_hobj_s {
  int_hobj_t m;
  type_table_t *tbl;
  int32_t n;
  type_t *elem;
} tuple_type_hobj_t;

typedef struct function_type_hobj_s {
  int_hobj_t m;
  type_table_t *tbl;
  type_t range;
  int32_t n;
  type_t *dom;
} function_type_hobj_t;


/*
 * Hash functions
 */
static uint32_t hash_bv_type(bv_type_hobj_t *p) {
  return jenkins_hash_pair(p->size, 0, 0x7838abe2);
}

static uint32_t hash_tuple_type(tuple_type_hobj_t *p) {
  return jenkins_hash_intarray_var(p->n, p->elem, 0x8193ea92);
}

static uint32_t hash_function_type(function_type_hobj_t *p) {
  uint32_t h;

  h = jenkins_hash_intarray_var(p->n, p->dom, 0x5ad7b72f);
  return jenkins_hash_pair(p->range, 0, h);
}


/*
 * Comparison functions
 */
static bool eq_bv_type(bv_type_hobj_t *p, type_t i) {
  type_table_t *table;

  table = p->tbl;
  return table->kind[i] == BITVECTOR_TYPE && table->desc[i].integer == p->size;
}

static bool eq_tuple_type(tuple_type_hobj_t *p, type_t i) {
  type_table_t *table;
  tuple_type_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != TUPLE_TYPE) return false;

  d = (tuple_type_t *) table->desc[i].ptr;
  if (d->nelem != p->n) return false;

  for (j=0; j<p->n; j++) {
    if (d->elem[j] != p->elem[j]) return false;
  }

  return true;
}

static bool eq_function_type(function_type_hobj_t *p, type_t i) {
  type_table_t *table;
  function_type_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != FUNCTION_TYPE) return false;

  d = (function_type_t *) table->desc[i].ptr;
  if (d->range != p->range || d->ndom != p->n) return false;

  for (j=0; j<p->n; j++) {
    if (d->domain[j] != p->dom[j]) return false;
  }

  return true;
}

/*
 * Builder functions
 */
static type_t build_bv_type(bv_type_hobj_t *p) {
  return new_bitvector_type(p->tbl, p->size);
}

static type_t build_tuple_type(tuple_type_hobj_t *p) {
  return new_tuple_type(p->tbl, p->n, p->elem);
}

static type_t build_function_type(function_type_hobj_t *p) {
  return new_function_type(p->tbl, p->n, p->dom, p->range);
}


/*
 * Global Hash Objects
 */
static bv_type_hobj_t bv_hobj = {
  { (hobj_hash_t) hash_bv_type, (hobj_eq_t) eq_bv_type, (hobj_build_t) build_bv_type },
  NULL,
  0,
};

static tuple_type_hobj_t tuple_hobj = {
  { (hobj_hash_t) hash_tuple_type, (hobj_eq_t) eq_tuple_type, (hobj_build_t) build_tuple_type },
  NULL,
  0,
  NULL,
};

static function_type_hobj_t function_hobj = {
  { (hobj_hash_t) hash_function_type, (hobj_eq_t) eq_function_type, (hobj_build_t) build_function_type },
  NULL,
  0,
  0,
  NULL,
};


/*
 * Initialize table: add the predefined types
 */
void init_type_table(type_table_t *table, uint32_t n) {
  type_table_init(table, n);
  add_primitive_types(table);
}

/*
 * Delete table: free all allocated memory
 */
void delete_type_table(type_table_t *table) {
  uint32_t i;

  // decrement refcount for all names
  for (i=0; i<table->nelems; i++) {
    if (table->name[i] != NULL) {
      string_decref(table->name[i]);
    }
  }

  // delete all allocated descriptors
  for (i=0; i<table->nelems; i++) {
    if (table->kind[i] == TUPLE_TYPE || table->kind[i] == FUNCTION_TYPE) {
      safe_free(table->desc[i].ptr);
    }
  }

  safe_free(table->kind);
  safe_free(table->desc);
  safe_free(table->name);
  delete_bitvector(table->root);
  delete_int_htbl(&table->htbl);
  delete_stbl(&table->stbl);

  table->kind = NULL;
  table->desc = NULL;
  table->name = NULL;
  table->root = NULL;
}


/*
 * Get predefined types
 */

/*
 * inlined functions in types.h:
 * bool_type(type_table_t *table);
 * int_type(type_table_t *table);
 * real_type(type_table_t *table);
 */

/*
 * Bitvector type
 */
type_t bv_type(type_table_t *table, int32_t size) {
  assert(size > 0);
  bv_hobj.tbl = table;
  bv_hobj.size = size;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bv_hobj);
}

/*
 * Tuple type
 */
type_t tuple_type(type_table_t *table, int32_t n, type_t elem[]) {
  assert(0 < n && n < MAX_TYPE_ARITY);
  tuple_hobj.tbl = table;
  tuple_hobj.n = n;
  tuple_hobj.elem = elem;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &tuple_hobj);
}

type_t tuple_type_pair(type_table_t *table, type_t t1, type_t t2) {
  type_t elems[2];

  elems[0] = t1;
  elems[1] = t2;
  tuple_hobj.tbl = table;
  tuple_hobj.n = 2;
  tuple_hobj.elem = elems;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &tuple_hobj);  
}

type_t tuple_type_triple(type_table_t *table, type_t t1, type_t t2, type_t t3) {
  type_t elems[3];

  elems[0] = t1;
  elems[1] = t2;
  elems[2] = t3;
  tuple_hobj.tbl = table;
  tuple_hobj.n = 3;
  tuple_hobj.elem = elems;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &tuple_hobj);  
}

/*
 * Function type
 */
type_t function_type(type_table_t *table, type_t range, int32_t n, type_t dom[]) {
  assert(0 < n && n < MAX_TYPE_ARITY);
  function_hobj.tbl = table;
  function_hobj.range = range;
  function_hobj.n = n;
  function_hobj.dom = dom;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &function_hobj);  
}

type_t unary_function_type(type_table_t *table, type_t range, type_t dom) {
  type_t doms[1];

  doms[0] = dom;
  function_hobj.tbl = table;
  function_hobj.range = range;
  function_hobj.n = 1;
  function_hobj.dom = doms;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &function_hobj);  
}

type_t binary_function_type(type_table_t *table, type_t range, type_t dom1, type_t dom2) {
  type_t doms[2];

  doms[0] = dom1;
  doms[1] = dom2;
  function_hobj.tbl = table;
  function_hobj.range = range;
  function_hobj.n = 2;
  function_hobj.dom = doms;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &function_hobj);  
}

type_t ternary_function_type(type_table_t *table, type_t range, type_t dom1, type_t dom2, type_t dom3) {
  type_t doms[3];

  doms[0] = dom1;
  doms[1] = dom2;
  doms[2] = dom3;
  function_hobj.tbl = table;
  function_hobj.range = range;
  function_hobj.n = 3;
  function_hobj.dom = doms;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &function_hobj);  
}




/*
 * Assign name to type i.
 * - previous mapping of name to other types (if any) are hidden.
 * - name must have a reference counter attached to it (cf. clone_string
 *   in memalloc.h).
 */
void set_type_name(type_table_t *table, type_t i, char *name) {
  if (table->name[i] == NULL) {
    table->name[i] = name;
    string_incref(name);
  }
  stbl_add(&table->stbl, name, i);
  string_incref(name);
}

/*
 * Get type mapped to the name (or NULL_TYPE)
 */
type_t get_type_by_name(type_table_t *table, char *name) {
  // NULL_TYPE = -1 and stbl_find returns -1 if name is absent
  return stbl_find(&table->stbl, name);
}

/*
 * Remove a type name.
 */
void remove_type_name(type_table_t *table, char *name) {
  stbl_remove(&table->stbl, name);
}



/*
 * TYPE CHECKING
 */

/*
 * Check whether tau1 is a subtype of tau2, using the rules
 * 1) int <= real
 * 2) tau <= tau
 * 3) if tau_1 <= sigma_1 ... tau_n <= sigma_n then
 *   (tuple-type tau_1 ... tau_n) <= (tuple-typle sigma_1 ... sigma_n)
 * 4) if sigma_1 <= sigma_2 then 
 *   (tau_1 ... tau_n --> sigma_1) <= (tau_1 ... tau_n -> sigma_2)
 */
bool is_subtype(type_table_t *table, type_t tau1, type_t tau2) {
  tuple_type_t *tup1, *tup2;
  function_type_t *fun1, *fun2;
  int32_t i, n;

  assert(good_type(table, tau1) && good_type(table, tau2));

  if (tau1 == tau2 || (tau1 == int_id && tau2 == real_id)) {
    return true;
  }

  switch (table->kind[tau1]) {
  case TUPLE_TYPE: 
    if (table->kind[tau2] == TUPLE_TYPE) {
      tup1 = tuple_type_desc(table, tau1);
      tup2 = tuple_type_desc(table, tau2);
      n = tup1->nelem;
      if (n != tup2->nelem) {
	return false;
      }
      for (i=0; i<n; i++) {
	if (! is_subtype(table, tup1->elem[i], tup2->elem[i])) {
	  return false;
	}
      }
      return true;
    }
    break;

  case FUNCTION_TYPE:
    if (table->kind[tau2] == FUNCTION_TYPE) {
      fun1 = function_type_desc(table, tau1);
      fun2 = function_type_desc(table, tau2);
      n = fun1->ndom;
      if (n != fun2->ndom) {
	return false;
      }
      for (i=0; i<n; i++) {
	if (fun1->domain[i] != fun2->domain[i]) {
	  return false;
	}
      }

      return is_subtype(table, fun1->range, fun2->range);
    }
    break;

  default:
    break;
  }

  return false;
}



/*
 * Check whether tau is a maximal type
 */
bool is_maxtype(type_table_t *table, type_t tau) {
  tuple_type_t *tup;
  function_type_t *fun;
  int32_t i, n;

  assert(good_type(table, tau));

  switch (table->kind[tau]) {
  case INT_TYPE:
    return false;

  case TUPLE_TYPE:
    tup = tuple_type_desc(table, tau);
    n = tup->nelem;
    for (i=0; i<n; i++) {
      if (! is_maxtype(table, tup->elem[i])) {
	return false;
      }
    }
    return true;

  case FUNCTION_TYPE:
    fun = function_type_desc(table, tau);
    return is_maxtype(table, fun->range);

  default:
    return true;
  }
}



/*
 * Sup of tau1 and tau2:
 * - returns the smallest type tau such that tau1 <= tau and tau2 <= tau
 * - returns NULL_TYPE if tau1 and tau2 are incompatible
 */
// construct (tuple-type (sup a[0] b[0]) ... (sup a[n-1] b[n-1]))
static type_t sup_tuple_types(type_table_t *table, uint32_t n, type_t *a, type_t *b) {
  type_t tmp[n]; // Warning: GCC/C99 extension 
  type_t aux;
  uint32_t i;

  for (i=0; i<n; i++) {
    aux = super_type(table, a[i], b[i]);
    if (aux == NULL_TYPE) return aux;
    tmp[i] = aux;
  }

  return tuple_type(table, n, tmp);
}

// construct (fun-type a[0] ... a[n-1] --> (sup tau1 tau2))
static type_t sup_fun_types(type_table_t *table, uint32_t n, type_t *a, type_t tau1, type_t tau2) {
  type_t range;

  range = super_type(table, tau1, tau2);
  if (range == NULL_TYPE) return range;

  return function_type(table, range, n, a);

}

type_t super_type(type_table_t *table, type_t tau1, type_t tau2) {
  tuple_type_t *tup1, *tup2;
  function_type_t *fun1, *fun2;
  int32_t i, n;

  if (tau1 == tau2) {
    return tau1;
  }
  if ((tau1 == int_id && tau2 == real_id) || 
      (tau1 == real_id && tau2 == int_id)) {
    return real_id;
  }

  switch (table->kind[tau1]) {
  case TUPLE_TYPE:
    if (table->kind[tau2] == TUPLE_TYPE) {
      tup1 = tuple_type_desc(table, tau1);
      tup2 = tuple_type_desc(table, tau2);
      n = tup1->nelem;
      if (n != tup2->nelem) {
	return NULL_TYPE;
      }
      return sup_tuple_types(table, n, tup1->elem, tup2->elem);
    }
    break;

  case FUNCTION_TYPE:
    if (table->kind[tau2] == FUNCTION_TYPE) {
      fun1 = function_type_desc(table, tau1);
      fun2 = function_type_desc(table, tau2);
      n = fun1->ndom;
      if (n != fun2->ndom) {
	return NULL_TYPE;
      }

      for (i=0; i<n; i++) {
	if (fun1->domain[i] != fun2->domain[i]) {
	  return NULL_TYPE;
	}
      }
      return sup_fun_types(table, n, fun1->domain, fun1->range, fun2->range);
    }
    break;

  default:
    break;
  }

  return NULL_TYPE;
}




/*
 * Inf of tau1 and tau2:
 * - returns the largest type tau such that tau <= tau1 and tau <= tau2
 * - returns NULL_TYPE if tau1 and tau2 are incompatible
 */
// construct (tuple-type (inf a[0] b[0]) ... (inf a[n-1] b[n-1]))
static type_t inf_tuple_types(type_table_t *table, uint32_t n, type_t *a, type_t *b) {
  type_t tmp[n]; // Warning: GCC/C99 extension 
  type_t aux;
  uint32_t i;

  for (i=0; i<n; i++) {
    aux = inf_type(table, a[i], b[i]);
    if (aux == NULL_TYPE) return aux;
    tmp[i] = aux;
  }

  return tuple_type(table, n, tmp);
}

// construct (fun-type a[0] ... a[n-1] --> (inf tau1 tau2))
static type_t inf_fun_types(type_table_t *table, uint32_t n, type_t *a, type_t tau1, type_t tau2) {
  type_t range;

  range = inf_type(table, tau1, tau2);
  if (range == NULL_TYPE) return range;

  return function_type(table, range, n, a);

}

type_t inf_type(type_table_t *table, type_t tau1, type_t tau2) {
  tuple_type_t *tup1, *tup2;
  function_type_t *fun1, *fun2;
  int32_t i, n;

  if (tau1 == tau2) {
    return tau1;
  }
  if ((tau1 == int_id && tau2 == real_id) || 
      (tau1 == real_id && tau2 == int_id)) {
    return int_id;
  }


  switch (table->kind[tau1]) {
  case TUPLE_TYPE:
    if (table->kind[tau2] == TUPLE_TYPE) {
      tup1 = tuple_type_desc(table, tau1);
      tup2 = tuple_type_desc(table, tau2);
      n = tup1->nelem;
      if (n != tup2->nelem) {
	return NULL_TYPE;
      }

      return inf_tuple_types(table, n, tup1->elem, tup2->elem);
    }
    break;

  case FUNCTION_TYPE:
    if (table->kind[tau2] == FUNCTION_TYPE) {
      fun1 = function_type_desc(table, tau1);
      fun2 = function_type_desc(table, tau2);
      n = fun1->ndom;
      if (n != fun2->ndom) {
	return NULL_TYPE;
      }

      for (i=0; i<n; i++) {
	if (fun1->domain[i] != fun2->domain[i]) {
	  return NULL_TYPE;
	}
      }

      return inf_fun_types(table, n, fun1->domain, fun1->range, fun2->range);
    }
    break;

  default:
    break;
  }

  return NULL_TYPE;
}


/*
 * Check whether tau1 and tau2 are compatible
 * (i.e., have a common supertype)
 */
bool compatible_types(type_table_t *table, type_t tau1, type_t tau2) {
  tuple_type_t *tup1, *tup2;
  function_type_t *fun1, *fun2;
  int32_t i, n;

  if (tau1 == tau2 ||
      (tau1 == int_id && tau2 == real_id) ||
      (tau1 == real_id && tau2 == int_id)) {
    return true;
  }

  switch (table->kind[tau1]) {
  case TUPLE_TYPE:
    if (table->kind[tau2] == TUPLE_TYPE) {
      // Two tuple types
      tup1 = tuple_type_desc(table, tau1);
      tup2 = tuple_type_desc(table, tau2);
      n = tup1->nelem;
      if (n != tup2->nelem) {
	return false;
      }
      for (i=0; i<n; i++) {
	if (! compatible_types(table, tup1->elem[i], tup2->elem[i])) {
	  return false;
	}
      }
      return true;
    }
    break;

  case FUNCTION_TYPE:
    if (table->kind[tau2] == FUNCTION_TYPE) {
      // Two function types
      fun1 = function_type_desc(table, tau1);
      fun2 = function_type_desc(table, tau2);
      n = fun1->ndom;
      if (n != fun2->ndom) {
	return false;
      }

      for (i=0; i<n; i++) {
	if (fun1->domain[i] != fun2->domain[i]) {
	  return false;
	}
      }
      return compatible_types(table, fun1->range, fun2->range);
    }
    break;

  default:
    break;
  }

  return false;
}






/*
 * FINITENESS
 */


/*
 * Check whether tau is a singleton type
 */
bool unit_type(type_table_t *table, type_t tau) {
  bool result;
  tuple_type_t *tup;
  function_type_t *fun;
  uint32_t i, n;

  assert(good_type(table, tau));

  switch (table->kind[tau]) {
  case SCALAR_TYPE:
    result = (scalar_type_cardinal(table, tau) == 1);
    break;

  case TUPLE_TYPE:
    tup = tuple_type_desc(table, tau);
    n = tup->nelem;
    for (i=0; i<n; i++) {
      if (! unit_type(table, tup->elem[i])) {
	result = false;
	goto done;
      }
    }
    result = true;
    break;

  case FUNCTION_TYPE:
    fun = function_type_desc(table, tau);
    result = unit_type(table, fun->range);
    break;

  default:
    result = false;
    break;
  }

 done:
  return result;
}



/*
 * Check whether all types in array a are finite.
 * n = size of the array
 */
static bool finite_type_array(type_table_t *table, type_t *a, int32_t n) {
  int32_t i;

  for (i=0; i<n; i++) {
    if (! finite_type(table, a[i])) {
      return false;
    }
  }
  return true;
}


/*
 * Check whether type tau is finite
 * - could be improved. May be expensive for deep tuple types
 */
bool finite_type(type_table_t *table, type_t tau) {
  bool result;
  tuple_type_t *tup;
  function_type_t *fun;

  assert(good_type(table, tau));

  switch (table->kind[tau]) {
  case BOOL_TYPE:
  case BITVECTOR_TYPE:
  case SCALAR_TYPE:
    result = true;
    break;

  case TUPLE_TYPE:
    tup = tuple_type_desc(table, tau);
    result = finite_type_array(table, tup->elem, tup->nelem);
    break;

  case FUNCTION_TYPE:
    // the domain is non empty so the type is finite
    // either if range is a singleton type of 
    // if both domain and range are finite
    fun = function_type_desc(table, tau);
    result = unit_type(table, fun->range) || 
      (finite_type(table, fun->range) && finite_type_array(table, fun->domain, fun->ndom));
    break;

  default:
    result = false;
    break;
  }

  return result;
}




/*
 * Check whether a function type has a finite domain
 * - tau must be a function type.
 */
bool type_has_finite_domain(type_table_t *table, type_t tau) {
  function_type_t *fun;

  fun = function_type_desc(table, tau);
  return finite_type_array(table, fun->domain, fun->ndom);
}





/*
 * Approximate cardinality of a tuple type
 * - return UINT32_MAX if the type is infinite or has cardinality >= UINT32_MAX
 */
static uint32_t tuple_type_card(type_table_t *table, tuple_type_t *d) {
  uint32_t i, n;
  uint64_t prod;

  n = d->nelem;
  prod = 1;
  for (i=0; i<n; i++) {
    prod *= card_of_type(table, d->elem[i]);
    if (prod >= UINT32_MAX) {
      return UINT32_MAX;
    }
  }
  assert(0 < prod && prod < UINT32_MAX);
  return (uint32_t) prod;
}



/*
 * Approximate cardianal of a function type
 * - return UINT32_MAX if the type is infinite or has cardinality >= UINT32_MAX
 */
static uint32_t function_type_card(type_table_t *table, function_type_t *d) {
  uint32_t i, n;
  uint32_t range;
  uint64_t dom, power;

  // range size
  range = card_of_type(table, d->range);
  assert(range > 0);
  if (range >= UINT32_MAX) {
    return UINT32_MAX;
  }
  if (range == 1) {
    return 1;
  }


  // domain size
  n = d->ndom;
  dom = 1;
  for (i=0; i<n; i++) {
    dom *= card_of_type(table, d->domain[i]);
    if (dom >= 32) {
      // since range >= 2, range^dom is >= UINT32_MAX
      return UINT32_MAX;
    }
  }

  // compute range^dom
  assert(range >= 2 && dom <= 31);
  power = 1;
  while (dom > 0) {
    power *= range;
    if (power >= UINT32_MAX) {
      return UINT32_MAX;
    }
    dom --;
  }
  
  assert(0 < power && power < UINT32_MAX);

  return (uint32_t) power;
}




/*
 * Cardinality of type tau
 * - return UINT32_MAX (i.e., 2^32 -1) if tau is infinite or is finite 
 *   and has cardinality >= 2^32 -1
 */
uint32_t card_of_type(type_table_t *table, type_t tau) {
  uint32_t card, n;

  assert(good_type(table, tau));

  card = UINT32_MAX;

  switch (table->kind[tau]) {
  case UNUSED_TYPE:
    assert(false);
  case INT_TYPE:
  case REAL_TYPE:
  case UNINTERPRETED_TYPE:
    // infinite types
    break;

  case BOOL_TYPE:
    card = 2;
    break;

  case BITVECTOR_TYPE:
    n = bv_type_size(table, tau);
    if (n < 32) {
      card = 1<<n;
    }
    break;

  case SCALAR_TYPE:
    card = scalar_type_cardinal(table, tau);
    break;

  case TUPLE_TYPE:
    card = tuple_type_card(table, tuple_type_desc(table, tau));
    break;

  case FUNCTION_TYPE:
    card = function_type_card(table, function_type_desc(table, tau));
    break;
  }

  return card;
}




/*
 * Approximate cardinality of tau[0] x ... x tau[n-1]
 * - return the same as card_of(tuple_type(tau[0] ... tau[n-1])) but does not 
 *   construct the tuple type
 * - return 1 if n=0
 */
uint32_t card_of_type_product(type_table_t *table, uint32_t n, type_t *tau) {
  uint32_t i;
  uint64_t prod;

  prod = 1;
  for (i=0; i<n; i++) {
    prod *= card_of_type(table, tau[i]);
    if (prod >= UINT32_MAX) {
      return UINT32_MAX;
    }
  }
  assert(0 < prod && prod < UINT32_MAX);
  return (uint32_t) prod;
}


/*
 * Approximate cardinality of the domain and range of a function type tau
 */
uint32_t card_of_domain_type(type_table_t *table, type_t tau) {
  function_type_t *d;

  d = function_type_desc(table, tau);
  return card_of_type_product(table, d->ndom, d->domain);
}

uint32_t card_of_range_type(type_table_t *table, type_t tau) {
  return card_of_type(table, function_type_range(table, tau));
}





/*
 * GARBAGE COLLECTION
 */
void set_root_type_flag(type_table_t *table, type_t i) {
  set_bit(table->root, i);
}

void clr_root_type_flag(type_table_t *table, type_t i) {
  clr_bit(table->root, i);
}


/*
 * Remove i from the hash-cons table
 */
static uint32_t hash_bvtype(int32_t size) {
  return jenkins_hash_pair(size, 0, 0x7838abe2);  
}

static uint32_t hash_tupletype(tuple_type_t *p) {
  return jenkins_hash_intarray_var(p->nelem, p->elem, 0x8193ea92);
}

static uint32_t hash_funtype(function_type_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray_var(p->ndom, p->domain, 0x5ad7b72f);
  return jenkins_hash_pair(p->range, 0, h);
}

static void erase_hcons_type(type_table_t *table, type_t i) {
  uint32_t k;

  switch (table->kind[i]) {
  case BITVECTOR_TYPE:
    k = hash_bvtype(table->desc[i].integer);
    break;

  case TUPLE_TYPE:
    k = hash_tupletype(table->desc[i].ptr);
    break;

  case FUNCTION_TYPE:
    k = hash_funtype(table->desc[i].ptr);
    break;

  default: 
    return;
  }

  int_htbl_erase_record(&table->htbl, k, i);
}

/*
 * Push element t into if it's not already marked
 */
static void gc_mark_push_type(int_queue_t *q, byte_t *mark, type_t t) {
  if (! tst_bit(mark, t)) {
    set_bit(mark, t);
    int_queue_push(q, t);
  }
}

/*
 * Push all unmarked elements of array a into q, and mark them
 */
static void gc_mark_push_array(int_queue_t *q, byte_t *mark, type_t *a, int32_t n) {
  int32_t i;
  for (i=0; i<n; i++) {
    gc_mark_push_type(q, mark, a[i]);
  }
}

/*
 * Mark type t to prevent its deletion. Must be called only from
 * within a gc_notifier. All types reachable from t's definition
 * are marked too.
 */
void gc_mark_type(type_table_t *table, type_t t) {
  int_queue_t *q;
  byte_t *mark;
  tuple_type_t *td;
  function_type_t *fd;
  
  assert(table->gc_mark != NULL);
  assert(table->gc_mark_queue != NULL);
  assert(int_queue_is_empty(table->gc_mark_queue));

  mark = table->gc_mark;
  if (! tst_bit(mark, t)) {
    set_bit(mark, t);
    q = table->gc_mark_queue;
    for (;;) {
      switch (table->kind[t]) {
      case TUPLE_TYPE:
	td = (tuple_type_t *) table->desc[t].ptr;
	gc_mark_push_array(q, mark, td->elem, td->nelem);
	break;

      case FUNCTION_TYPE:
	fd = (function_type_t *) table->desc[t].ptr;
	gc_mark_push_type(q, mark, fd->range);
	gc_mark_push_array(q, mark, fd->domain, fd->ndom);
	break;
      }

      if (int_queue_is_empty(q)) break;
      t = int_queue_pop(q);
    }
  }
  
}

/*
 * Mark all types with root_flag set and all types accessible from the symbol table.
 */
static void mark_live_types(type_table_t *table) {
  stbl_t *sym_table;
  stbl_bank_t *b;
  stbl_rec_t *r;
  uint32_t k;
  type_t i;

  // scan symbol table
  sym_table = &table->stbl;
  k = sym_table->free_idx;
  for (b = sym_table->bnk; b != NULL; b = b->next) {
    for (r = b->block + k; r < b->block + STBL_BANK_SIZE; r ++) {
      if (r->string != NULL) {
	gc_mark_type(table, r->value);
      }
    }
    k = 0;
  }

  // mark every type with root_flag == 1
  for (i=0; i<table->nelems; i++) {
    if (table->kind[i] != UNUSED_TYPE && tst_bit(table->root, i)) {
      gc_mark_type(table, i);
    }
  }
}


/*
 * Trigger garbage collection
 */
void type_table_garbage_collection(type_table_t *table) {
  int32_t n;
  int_queue_t queue;
  byte_t *mark;
  type_t i;

  // allocate/initialize gc_mark and mark_queue
  init_int_queue(&queue, 0);
  n = table->nelems;
  mark = allocate_bitvector(n);
  clear_bitvector(mark, n);
  table->gc_mark = mark;
  table->gc_mark_queue = &queue;

  // mark types: primitive types + internal + any types marked by the notifier
  set_bit(mark, bool_id);
  set_bit(mark, int_id);
  set_bit(mark, real_id);
  mark_live_types(table);

  table->gc_notifier(table);

  // delete all unmarked types
  for (i=0; i<n; i++) {
    if (! tst_bit(mark, i)) {
      erase_hcons_type(table, i);
      erase_type(table, i);
    }
  }

  // cleanup
  table->gc_mark_queue = NULL;
  table->gc_mark = NULL;
  delete_bitvector(mark);
  delete_int_queue(&queue);
}


