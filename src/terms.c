/*
 * INTERNAL TERM REPRESENTATION AND HASH CONSING
 */

/*
 * The internal terms include:
 * 1) constants:
 *    - constants of uninterpreted/scalar
 *    - global uninterpreted constants 
 * 2) generic terms
 *    - ite c t1 t2
 *    - eq t1 t2
 *    - apply f t1 ... t_n
 *    - mk-tuple t1 ... t_n
 *    - select i tuple
 *    - update f t1 ... t_n v
 *    - distinct t1 ... t_n
 * 3) variables and quantifiers
 *    - variables are identified by their type and an integer index.
 *    - quantified formulas are of the form (forall v_1 ... v_n term)
 *      where each v_i is a variable
 * 4) boolean operators
 *    - or t1 ... t_n
 *    - xor t1 ... t_n
 *    - bit i u (extract bit i of a bitvector term u)
 * 6) arithmetic terms and atoms
 *    - terms are either rational constants, power products, or 
 *      polynomials with rational coefficients
 *    - atoms are either of the form (p == 0) or (p >= 0)
 *      where p is a polynomial.
 *    - atoms a x - a y == 0 are rewritten to (x = y)
 * 7) bitvector terms and atoms
 *    - bitvector constants
 *    - power products
 *    - polynomials
 *    - bit arrays
 *    - other operations: divisions/shift
 *    - atoms: three binary predicates
 *      bv_eq t1 t2
 *      bv_ge t1 t2 (unsigned comparison: t1 >= t2)
 *      bv_sge t1 t2 (signed comparison: t1 >= t2)
 *
 * Every term is an index t in a global term table,
 * where 0 <= t <= 2^30. The two term occurrences
 * t+ and t- are encoded on 32bits (signed integer) with
 * - bit[31] = sign bit = 0
 * - bits[30 ... 1] = t
 * - bit[0] = polarity bit: 0 means t+, 1 means t-
 *
 * For every term, we keep:
 * - type[t] (index in the type table)
 * - name[t] (either a string or NULL)
 * - kind[t] (what kind of term it is)
 * - desc[t] = descriptor that depends on the kind
 */

#include "memalloc.h"
#include "refcount_strings.h"
#include "hash_functions.h"
#include "term_occurrences.h"
#include "terms.h"


#if 0

/*
 * Finalizer for term names in the symbol table.
 * All symbols must be generated by the clone function, and have
 * a reference counter (cf. memalloc.h).
 */
static void term_name_finalizer(stbl_rec_t *r) {
  string_decref(r->string);
}


/*
 * Initialize table, with initial size = n.
 * - ttbl is the type table.
 * - arith_m: arithmetic variable manager
 * - bv_m: bitvector variable manager
 */
static void term_table_init(term_table_t *table, uint32_t n, type_table_t *ttbl, 
			    arithvar_manager_t *arith_m, bv_var_manager_t *bv_m) {
  // abort if size is too large
  if (n >= MAX_TERMS) {
    out_of_memory();
  }

  table->kind = (unsigned char *) safe_malloc(n * sizeof(unsigned char));
  table->type = (type_t *) safe_malloc(n * sizeof(type_t));
  table->desc = (term_desc_t *) safe_malloc(n * sizeof(term_desc_t));
  table->name = (char **) safe_malloc(n * sizeof(char *));
  table->theory_var = (int32_t *) safe_malloc(n * sizeof(int32_t));
  table->root = allocate_bitvector(n);

  table->type_table = ttbl;
  table->arith_manager = arith_m;
  table->bv_manager = bv_m;

  table->size = n;
  table->nelems = 0;
  table->free_idx = -1; // empty free list

  // initialize hashtable and symbol table with default initial size 
  init_int_htbl(&table->htbl, 0);
  init_stbl(&table->stbl, 0);

  // attach the name finalizer to stbl
  stbl_set_finalizer(&table->stbl, term_name_finalizer);


  // empty internal buffer
  table->buffer_size = 0;
  table->buffer = NULL;

  // no gc objects
  table->gc_mark = NULL;
  table->gc_mark_queue = NULL;
  table->gc_bit_marker = NULL;
  table->gc_notifier = default_gc_notifier;
}


/*
 * Extend the table: make it 50% larger
 */
static void term_table_extend(term_table_t *table) {
  uint32_t n;

  n = table->size + 1;
  n += n >> 1;

  // force abort if too large
  if (n >= MAX_TERMS) {
    out_of_memory();
  }

  table->kind = (unsigned char *) safe_realloc(table->kind, n * sizeof(unsigned char));
  table->type = (type_t *) safe_realloc(table->type, n * sizeof(type_t));
  table->desc = (term_desc_t *) safe_realloc(table->desc, n * sizeof(term_desc_t));
  table->name = (char **) safe_realloc(table->name, n * sizeof(char *));
  table->theory_var = (int32_t *) safe_realloc(table->theory_var, n * sizeof(int32_t));
  table->root = extend_bitvector(table->root, n);
  table->size = n;
}


/*
 * Allocate a new term id
 * - set its root mark to 0, its name to NULL, and its theory var to null
 */
static term_t allocate_term_id(term_table_t *table) {
  term_t i;

  i = table->free_idx;
  if (i >= 0) {
    table->free_idx = table->desc[i].integer;
  } else {
    i = table->nelems;
    table->nelems ++;
    if (i >= table->size) {
      term_table_extend(table);
    }
  }
  table->name[i] = NULL;
  table->theory_var[i] = null_theory_var;
  clr_bit(table->root, i);

  return i;
}


/*
 * Add the two primitive constants (true/false)
 * - false is constant 0 of type bool
 * - true is constant 1 of type bool
 */
static void add_primitive_terms(term_table_t *table) {
  term_t i;
  type_t tau;

  tau = bool_type(table->type_table);

  i = constant_term(table, tau, 0);
  assert(i == false_term_id);

  i = constant_term(table, tau, 1);
  assert(i == true_term_id);
}



/*
 * Resize the internal buffer to at least n.
 * The current buffer is lost.
 */
static void resize_buffer(term_table_t *table, int32_t n) {
  if (table->buffer_size < n) {
    table->buffer = (int32_t *) safe_realloc(table->buffer, n * sizeof(int32_t));
    table->buffer_size = n;
  }
}


/*
 * Delete theory variable attached to term i
 */
static void delete_theory_var(term_table_t *table, term_t i) {
  int32_t v;

  v = table->theory_var[i];

  assert(v != null_theory_var);
  if (is_arithmetic_type(table->type[i])) {
    arithvar_manager_delete_var(table->arith_manager, v);
  } else {
    assert(is_bitvector_term(table, i));
    bv_var_manager_delete_var(table->bv_manager, v);    
  }
}


/*
 * Erase term i.
 */
static void erase_term(term_table_t *table, term_t i) {
  // Don't delete true or false
  if (i == true_term_id || i == false_term_id) 
    return;

  // Free the descriptor if needed
  switch (table->kind[i]) {
  case UNUSED_TERM:
    return;
  case CONSTANT_TERM:
  case UNINTERPRETED_TERM:
  case VARIABLE:
  case NOT_TERM:
    break;

  case ITE_TERM:
  case EQ_TERM:
  case APP_TERM:
  case OR_TERM:
  case TUPLE_TERM:
  case SELECT_TERM:
  case UPDATE_TERM:
  case DISTINCT_TERM:
  case FORALL_TERM:
    safe_free(table->desc[i].ptr);
    break;

  case ARITH_TERM:
  case ARITH_EQ_ATOM:
  case ARITH_GE_ATOM:
    free_polynomial(table->desc[i].ptr);
    break;

  case ARITH_BINEQ_ATOM:
  case BV_LOGIC_TERM:    
  case BV_ARITH_TERM:
  case BV_CONST_TERM:
  case BV_EQ_ATOM:
  case BV_GE_ATOM:
  case BV_SGE_ATOM:
  case BV_APPLY_TERM:
    safe_free(table->desc[i].ptr);
    break;
  }

  if (table->theory_var[i] != null_theory_var) {
    delete_theory_var(table, i);
    table->theory_var[i] = null_theory_var;
  }

  if (table->name[i] != NULL) {
    string_decref(table->name[i]);
    table->name[i] = NULL;
  }

  table->type[i] = NULL_TYPE;
  table->kind[i] = UNUSED_TERM;
  table->desc[i].integer = table->free_idx;
  table->free_idx = i;
}





/*
 * Add a constant term
 */
static term_t new_constant_term(term_table_t *table, type_t tau, int32_t index) {
  term_t i;

  i = allocate_term_id(table);
  table->kind[i] = CONSTANT_TERM;
  table->type[i] = tau;
  table->desc[i].integer = index;

  return i;
}


/*
 * Add a new uninterpreted constant.
 */
term_t new_uninterpreted_term(term_table_t *table, type_t tau) {
  term_t i;

  i = allocate_term_id(table);
  table->kind[i] = UNINTERPRETED_TERM;
  table->type[i] = tau;
  table->desc[i].ptr = NULL;

  return i;
}


/*
 * Add a new variable of the type tau and given index
 */
static term_t new_variable(term_table_t *table, type_t tau, int32_t index) {
  term_t i;

  i = allocate_term_id(table);
  table->kind[i] = VARIABLE;
  table->type[i] = tau;
  table->desc[i].integer = index;

  return i;
}


/*
 * Create term (not t1)
 */
static term_t new_not_term(term_table_t *table, term_t t1) {
  term_t i;

  i = allocate_term_id(table);
  table->kind[i] = NOT_TERM;
  table->type[i] = bool_type(table->type_table);
  table->desc[i].integer = t1;

  return i;
}


/*
 * Create term (ite c t1 t2).
 * tau must be super_type(t1's type, t2's type)
 */
static term_t new_ite_term(term_table_t *table, term_t c, term_t t1, term_t t2, type_t tau) {
  term_t i;
  ite_term_t *d;

  d = (ite_term_t *) safe_malloc(sizeof(ite_term_t));
  d->cond = c;
  d->then_arg = t1;
  d->else_arg = t2;

  i = allocate_term_id(table);
  table->kind[i] = ITE_TERM;
  table->type[i] = tau;
  table->desc[i].ptr = d;

  return i;
}


/*
 * Create term (eq t1 t2)
 */
static term_t new_eq_term(term_table_t *table, term_t t1, term_t t2) {
  term_t i;
  eq_term_t *d;

  d = (eq_term_t *) safe_malloc(sizeof(eq_term_t));
  d->left = t1;
  d->right = t2;

  i = allocate_term_id(table);
  table->kind[i] = EQ_TERM;
  table->type[i] = bool_type(table->type_table);
  table->desc[i].ptr = d;

  return i;
}


/*
 * Create term (f a[0] ... a[n-1])
 */
static term_t new_app_term(term_table_t *table, term_t f, int32_t n, term_t *a) {
  term_t i;
  app_term_t *d;
  int32_t j;

  d = (app_term_t *) safe_malloc(sizeof(app_term_t) + n * sizeof(term_t));
  d->nargs = n;
  d->fun = f;
  for (j=0; j<n; j++) d->arg[j] = a[j];

  i = allocate_term_id(table);
  table->kind[i] = APP_TERM;
  table->type[i] = function_type_range(table->type_table, table->type[f]);
  table->desc[i].ptr = d;

  return i;
}


/*
 * Create disjuncion (or a[0] ... a[n-1])
 */
static term_t new_or_term(term_table_t *table, int32_t n, term_t *a) {
  term_t i;
  or_term_t *d;
  int32_t j;

  d = (or_term_t *) safe_malloc(sizeof(or_term_t) + n * sizeof(term_t));
  d->nargs = n;
  for (j=0; j<n; j++) d->arg[j] = a[j];

  i = allocate_term_id(table);
  table->kind[i] = OR_TERM;
  table->type[i] = bool_type(table->type_table);
  table->desc[i].ptr = d;

  return i;
}


/*
 * Create tuple literal (mk-tuple a[0] .... a[n-1])
 */
static term_t new_tuple_term(term_table_t *table, int32_t n, term_t *a) {
  term_t i;
  tuple_term_t *d;
  int32_t j, *b;

  d = (tuple_term_t *) safe_malloc(sizeof(tuple_term_t) + n * sizeof(term_t));
  d->nargs = n;

  // copy tuple components in d and collect their types
  resize_buffer(table, n);
  b = table->buffer;
  for (j=0; j<n; j++) {
    i = a[j];
    d->arg[j] = i;
    b[j] = table->type[i];
  }

  i = allocate_term_id(table);
  table->kind[i] = TUPLE_TERM;
  table->type[i] = tuple_type(table->type_table, n, b);
  table->desc[i].ptr = d;

  return i;
}


/*
 * Tuple selection
 */
static term_t new_select_term(term_table_t *table, int32_t index, term_t tuple) {
  term_t i;
  select_term_t *d;

  d = (select_term_t *) safe_malloc(sizeof(select_term_t));
  d->idx = index;
  d->arg = tuple;

  i = allocate_term_id(table);
  table->kind[i] = SELECT_TERM;
  table->type[i] = tuple_type_component(table->type_table, table->type[tuple], index);
  table->desc[i].ptr = d;

  return i;
}


/*
 * Update term: (update f a[0] ... a[n-1] v)
 */
static term_t new_update_term(term_table_t *table, term_t f, int32_t n, term_t *a, term_t v) {
  term_t i;
  update_term_t *d;
  int32_t j;

  d = (update_term_t *) safe_malloc(sizeof(update_term_t) + n * sizeof(term_t));
  d->fun = f;
  d->newval = v;
  d->nargs = n;
  for (j=0; j<n; j++) d->arg[j] = a[j];

  i = allocate_term_id(table);
  table->kind[i] = UPDATE_TERM;
  table->type[i] = table->type[f];
  table->desc[i].ptr = d;

  return i;
}


/*
 * Create (distinct a[0] .... a[n-1])
 */
static term_t new_distinct_term(term_table_t *table, int32_t n, term_t *a) {
  term_t i;
  distinct_term_t *d;
  int32_t j;

  d = (distinct_term_t *) safe_malloc(sizeof(distinct_term_t) + n * sizeof(term_t));
  d->nargs = n;
  for (j=0; j<n; j++) d->arg[j] = a[j];


  i = allocate_term_id(table);
  table->kind[i] = DISTINCT_TERM;
  table->type[i] = bool_type(table->type_table);
  table->desc[i].ptr = d;

  return i;
}


/*
 * (forall (var[0] ... var[n-1]) body)
 */
static term_t new_forall_term(term_table_t *table, int32_t n, term_t *var, term_t body) {
  term_t i;
  forall_term_t *d;
  int32_t j;

  d = (forall_term_t *) safe_malloc(sizeof(forall_term_t) + n * sizeof(term_t));
  d->nvars = n;
  d->body = body;
  for (j=0; j<n; j++) d->var[j] = var[j];

  i = allocate_term_id(table);
  table->kind[i] = FORALL_TERM;
  table->type[i] = bool_type(table->type_table);
  table->desc[i].ptr = d;

  return i;
}


/*
 * Arithmetic term
 */
static term_t new_arith_term(term_table_t *table, polynomial_t *p) {
  term_t i;

  i = allocate_term_id(table);
  table->kind[i] = ARITH_TERM;
  if (is_int_monarray(p->mono, table->arith_manager)) {
    table->type[i] = int_type(table->type_table);
  } else {
    table->type[i] = real_type(table->type_table);
  }
  table->desc[i].ptr = p;

  return i;
}


/*
 * Arithmetic atom: tag must be either ARITH_EQ_ATOM or ARITH_GE_ATOM
 */
static term_t new_arith_atom(term_table_t *table, term_kind_t tag, polynomial_t *p) {
  term_t i;

  assert(tag == ARITH_EQ_ATOM || tag == ARITH_GE_ATOM);
  i = allocate_term_id(table);
  table->kind[i] = tag;
  table->type[i] = bool_type(table->type_table);
  table->desc[i].ptr = p;

  return i;
}


/*
 * New arithmetic equality. t1 and t2 must be arithmetic terms
 */
static term_t new_arith_bineq_atom(term_table_t *table, term_t t1, term_t t2) {
  term_t i;
  arith_bineq_t *d;

  d = (arith_bineq_t *) safe_malloc(sizeof(arith_bineq_t));
  d->left = t1;
  d->right = t2;

  i = allocate_term_id(table);
  table->kind[i] = ARITH_BINEQ_ATOM;
  table->type[i] = bool_type(table->type_table);
  table->desc[i].ptr = d;

  return i;
}


/*
 * Bit-vector arithmetic term
 */
static term_t new_bvarith_term(term_table_t *table, bvarith_expr_t *bv) {
  term_t i;

  i = allocate_term_id(table);
  table->kind[i] = BV_ARITH_TERM;
  table->type[i] = bv_type(table->type_table, bv->size);
  table->desc[i].ptr = bv;

  return i;
}


/*
 * Bit-vector logical term
 */
static term_t new_bvlogic_term(term_table_t *table, bvlogic_expr_t *bv) {
  term_t i;

  i = allocate_term_id(table);
  table->kind[i] = BV_LOGIC_TERM;
  table->type[i] = bv_type(table->type_table, bv->nbits);
  table->desc[i].ptr = bv;

  return i;
}


/*
 * Bitvector constant
 */
static term_t new_bvconst_term(term_table_t *table, int32_t n, uint32_t *b) {
  bvconst_term_t *d;
  int32_t j, w;
  term_t i;

  w = (n + 31) >> 5; // ceil(n/32)
  d = (bvconst_term_t *) safe_malloc(sizeof(bvconst_term_t) + w * sizeof(uint32_t));
  d->nbits = n;
  for (j=0; j<w; j++) d->bits[j] = b[j];

  i = allocate_term_id(table);
  table->kind[i] = BV_CONST_TERM;
  table->type[i] = bv_type(table->type_table, n);
  table->desc[i].ptr = d;

  return i;
}


/*
 * Bit-vector atom: tag must be BV_EQ_ATOM, BV_GE_ATOM, BV_SGE_ATOM
 */
static term_t new_bvatom(term_table_t *table, term_kind_t tag, term_t l, term_t r) {
  term_t i;
  bv_atom_t *d;

  assert(tag == BV_EQ_ATOM || tag == BV_GE_ATOM || tag == BV_SGE_ATOM);

  d = (bv_atom_t *) safe_malloc(sizeof(bv_atom_t));
  d->left = l;
  d->right = r;

  i = allocate_term_id(table);
  table->kind[i] = tag;
  table->type[i] = bool_type(table->type_table);
  table->desc[i].ptr = d;

  return i;
}

/*
 * Overloaded binary operations on bitvectors
 */
static term_t new_bvapply_term(term_table_t *table, uint32_t op, term_t l, term_t r) {
  term_t i;
  bvapply_term_t *d;  

  assert(is_bitvector_term(table, l) && is_bitvector_term(table, r));
  assert(term_type(table, l) == term_type(table, r));

  d = (bvapply_term_t *) safe_malloc(sizeof(bvapply_term_t));
  d->op = op;
  d->arg0 = l;
  d->arg1 = r;

  i = allocate_term_id(table);
  table->kind[i] = BV_APPLY_TERM;
  table->type[i] = term_type(table, l);
  table->desc[i].ptr = d;

  return i;
}



/**************************
 *  HASH CONSING SUPPORT  *
 *************************/

/*
 * Objects for interfacing with int_hash_table
 * - each object type corresponds to a term kind
 * - it starts with a method descriptor m 
 *   with three fields:
 *     m.hash: hash function
 *     m.eq: check for equality
 *     m.build: construct fresh term
 * - other fields are a term table, and all the 
 *   subcomponents for the term kind.
 * - for an object o, 
 *    o->m.hash(o) = hash code for o
 *    o->m.eq(o, i): check whether o equals term i
 *    o->m.build(o): add o to the term table and return its index
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  int32_t idx;
} constant_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  int32_t idx;
} variable_hobj_t;
 
typedef struct {
  int_hobj_t m;       // methods
  term_table_t *tbl;  // term table
  term_t cond, then_arg, else_arg;
  type_t type; // supertype of then and else's types
} ite_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_t left, right;
} eq_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  int32_t nargs;
  term_t fun;
  term_t *arg;
} app_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  int32_t nargs;
  term_t *arg;
} or_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_t arg;
} not_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  int32_t nargs;
  term_t *arg;
} tuple_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  int32_t idx;
  term_t arg;
} select_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_t fun;
  term_t newval;
  int32_t nargs;
  term_t *arg;
} update_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  int32_t nargs;
  term_t *arg;
} distinct_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_t body;
  int32_t nvars;
  type_t *var;
} forall_term_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  arith_buffer_t *b;
  term_kind_t tag;
} arith_buffer_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  monomial_t *mono;
  int32_t nterms;
  term_kind_t tag;
} monarray_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_t left, right;
} arith_bineq_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  bvarith_buffer_t *b;
} bvarith_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  bvlogic_buffer_t *b;
} bvlogic_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  int32_t nbits;
  uint32_t *bits;
} bvconst_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_t left, right;
  term_kind_t tag;
} bvatom_hobj_t;

typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  uint32_t op;
  term_t arg0, arg1;
} bvapply_term_hobj_t;


/*
 * Hash functions
 */
static uint32_t hash_constant_term(constant_term_hobj_t *p) {
  return jenkins_hash_pair(p->tau, p->idx, 0x19ef312c);
}

static uint32_t hash_variable(variable_hobj_t *p) {
  return jenkins_hash_pair(p->tau, p->idx, 0x83891aef);
}

static uint32_t hash_ite_term(ite_term_hobj_t *p) {
  return jenkins_hash_triple(p->cond, p->then_arg, p->else_arg, 0x9f34197a);
}

static uint32_t hash_eq_term(eq_term_hobj_t *p) {
  return jenkins_hash_pair(p->left, p->right, 0x78d2bae1);
}

static uint32_t hash_app_term(app_term_hobj_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray(p->nargs, p->arg);
  return jenkins_hash_pair(p->fun, 0, h);
}

static uint32_t hash_or_term(or_term_hobj_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0xf82bf286);
}

static uint32_t hash_not_term(not_term_hobj_t *p) {
  return jenkins_hash_pair(p->arg, 0, 0x183b42e6);
}

static uint32_t hash_tuple_term(tuple_term_hobj_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0xae7bd466);
}

static uint32_t hash_select_term(select_term_hobj_t *p) {
  return jenkins_hash_pair(p->arg, p->idx, 0x4137bee9);
}

static uint32_t hash_update_term(update_term_hobj_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray_var(p->nargs, p->arg, 0x378a121a);
  return jenkins_hash_pair(p->fun, p->newval, h);
}

static uint32_t hash_distinct_term(distinct_term_hobj_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0x783426);
}

static uint32_t hash_forall_term(forall_term_hobj_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray_var(p->nvars, p->var, 0x9172ea9f);
  return jenkins_hash_pair(p->body, 0, h);
}

static uint32_t hash_arith_buffer_term(arith_buffer_hobj_t *p) {
  uint32_t h;
  h = arith_buffer_hash(p->b);
  return jenkins_hash_pair(p->tag, 0, h);
}

static uint32_t hash_monarray_term(monarray_hobj_t *p) {
  uint32_t h;
  h = hash_monarray(p->mono);
  return jenkins_hash_pair(p->tag, 0, h);
}

static uint32_t hash_arith_bineq_atom(arith_bineq_hobj_t *p) {
  return jenkins_hash_pair(p->left, p->right, 0x761bedaf);
}

static uint32_t hash_bvarith_term(bvarith_hobj_t *p) {
  return bvarith_buffer_hash(p->b);
}

static uint32_t hash_bvlogic_term(bvlogic_hobj_t *p) {
  return bvlogic_buffer_hash(p->b);
}

static uint32_t hash_bvconst_term(bvconst_hobj_t *p) {
  int32_t k;
  k = (p->nbits + 31) >> 5; // number of 32-bit words 
  return jenkins_hash_intarray_var(k, (int32_t *) p->bits, 0x71837ae4);
}

static uint32_t hash_bvatom(bvatom_hobj_t *p) {
  return jenkins_hash_triple(p->left, p->right, p->tag, 0x7aaf3277);
}

static uint32_t hash_bvapply_term(bvapply_term_hobj_t *p) {
  return jenkins_hash_triple(p->op, p->arg0, p->arg1, 0x8317ed8);
}



/*
 * Equality tests
 */
static bool equal_constant_term(constant_term_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  return table->kind[i] == CONSTANT_TERM && table->type[i] == p->tau &&
    table->desc[i].integer == p->idx;
}

static bool equal_variable(variable_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  return table->kind[i] == VARIABLE && table->type[i] == p->tau &&
    table->desc[i].integer == p->idx;
}

static bool equal_ite_term(ite_term_hobj_t *p, term_t i) {
  term_table_t *table;
  ite_term_t *d;

  table = p->tbl;
  if (table->kind[i] != ITE_TERM) return false;

  d = (ite_term_t *) table->desc[i].ptr;
  return d->cond == p->cond && d->then_arg == p->then_arg && d->else_arg == p->else_arg;
}

static bool equal_eq_term(eq_term_hobj_t *p, term_t i) {
  term_table_t *table;
  eq_term_t *d;

  table = p->tbl;
  if (table->kind[i] != EQ_TERM) return false;

  d = (eq_term_t *) table->desc[i].ptr;
  return d->left == p->left && d->right == p->right;
}

static bool equal_app_term(app_term_hobj_t *p, term_t i) {
  term_table_t *table;
  app_term_t *d;
  uint32_t j;

  table = p->tbl;
  if (table->kind[i] != APP_TERM) return false;

  d = (app_term_t *) table->desc[i].ptr;
  if (d->fun != p->fun) return false;

  assert(d->nargs == p->nargs);
  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_or_term(or_term_hobj_t *p, term_t i) {
  term_table_t *table;
  or_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != OR_TERM) return false;

  d = (or_term_t *) table->desc[i].ptr;
  if (d->nargs != p->nargs) return false;

  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_not_term(not_term_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;

  return table->kind[i] == NOT_TERM && table->desc[i].integer == p->arg;
}

static bool equal_tuple_term(tuple_term_hobj_t *p, term_t i) {
  term_table_t *table;
  tuple_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != TUPLE_TERM) return false;

  d = (tuple_term_t *) table->desc[i].ptr;
  if (d->nargs != p->nargs) return false;

  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_select_term(select_term_hobj_t *p, term_t i) {
  term_table_t *table;
  select_term_t *d;

  table = p->tbl;
  if (table->kind[i] != SELECT_TERM) return false;

  d = (select_term_t *) table->desc[i].ptr;
  return p->idx == d->idx && p->arg == d->arg;
}

static bool equal_update_term(update_term_hobj_t *p, term_t i) {
  term_table_t *table;
  update_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != UPDATE_TERM) return false;

  d = (update_term_t *) table->desc[i].ptr;
  if (d->fun != p->fun || d->newval != p->newval) return false;

  assert(d->nargs == p->nargs);
  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_distinct_term(distinct_term_hobj_t *p, term_t i) {
  term_table_t *table;
  distinct_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != DISTINCT_TERM) return false;

  d = (distinct_term_t *) table->desc[i].ptr;
  if (d->nargs != p->nargs) return false;

  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_forall_term(forall_term_hobj_t *p, term_t i) {
  term_table_t *table;
  forall_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != FORALL_TERM) return false;

  d = (forall_term_t *) table->desc[i].ptr;
  if (d->nvars != p->nvars || d->body != p->body) return false;

  for (j=0; j<p->nvars; j++) {
    if (d->var[j] != p->var[j]) return false;
  }

  return true;
}

static bool equal_arith_buffer_term(arith_buffer_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  if (table->kind[i] != p->tag) return false;

  return arith_buffer_equal_polynomial(p->b, (polynomial_t *) table->desc[i].ptr);
}

static bool equal_monarray_term(monarray_hobj_t *p, term_t i) {
  term_table_t *table;
  polynomial_t *d;

  table = p->tbl;
  if (table->kind[i] != p->tag) return false;
  d = (polynomial_t *) table->desc[i].ptr;
  return p->nterms == d->nterms && equal_monarray(p->mono, d->mono);
}

static bool equal_arith_bineq_atom(arith_bineq_hobj_t *p, term_t i) {
  term_table_t *table;
  arith_bineq_t *d;

  table = p->tbl;
  if (table->kind[i] != ARITH_BINEQ_ATOM) return false;

  d = (arith_bineq_t *) table->desc[i].ptr;
  return d->left == p->left && d->right == p->right;
}

static bool equal_bvarith_term(bvarith_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  if (table->kind[i] != BV_ARITH_TERM) return false;

  return bvarith_buffer_equal_expr(p->b, (bvarith_expr_t *) table->desc[i].ptr);
}

static bool equal_bvlogic_term(bvlogic_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  if (table->kind[i] != BV_LOGIC_TERM) return false;
  return bvlogic_buffer_equal_expr(p->b, (bvlogic_expr_t *) table->desc[i].ptr);
}

static bool equal_bvconst_term(bvconst_hobj_t *p, term_t i) {
  term_table_t *table;
  bvconst_term_t *d;  

  table = p->tbl;
  if (table->kind[i] != BV_CONST_TERM) return false;

  d = (bvconst_term_t *) table->desc[i].ptr;
  return d->nbits == p->nbits && bvconst_eq(d->bits, p->bits, (p->nbits + 31) >> 5);
}

static bool equal_bvatom(bvatom_hobj_t *p, term_t i) {
  term_table_t *table;
  bv_atom_t *d;

  table = p->tbl;
  if (table->kind[i] != p->tag) return false;

  d = (bv_atom_t *) table->desc[i].ptr;
  return d->left == p->left && d->right == p->right;
}

static bool equal_bvapply_term(bvapply_term_hobj_t *p, term_t i) {
  term_table_t *table;
  bvapply_term_t *d;

  table = p->tbl;
  if (table->kind[i] != BV_APPLY_TERM) return false;

  d = (bvapply_term_t *) table->desc[i].ptr;
  return d->arg0 == p->arg0 && d->arg1 == p->arg1 && d->op == p->op;
}


/*
 * Build functions
 */
static term_t build_constant_term(constant_term_hobj_t *p) {
  return new_constant_term(p->tbl, p->tau, p->idx);
}

static term_t build_variable(variable_hobj_t *p) {
  return new_variable(p->tbl, p->tau, p->idx);
}

static term_t build_ite_term(ite_term_hobj_t *p) {
  return new_ite_term(p->tbl, p->cond, p->then_arg, p->else_arg, p->type);
}

static term_t build_eq_term(eq_term_hobj_t *p) {
  return new_eq_term(p->tbl, p->left, p->right);
}

static term_t build_app_term(app_term_hobj_t *p) {
  return new_app_term(p->tbl, p->fun, p->nargs, p->arg);
}

static term_t build_or_term(or_term_hobj_t *p) {
  return new_or_term(p->tbl, p->nargs, p->arg);
}

static term_t build_not_term(not_term_hobj_t *p) {
  return new_not_term(p->tbl, p->arg);
}

static term_t build_tuple_term(tuple_term_hobj_t *p) {
  return new_tuple_term(p->tbl, p->nargs, p->arg);
}

static term_t build_select_term(select_term_hobj_t *p) {
  return new_select_term(p->tbl, p->idx, p->arg);
}

static term_t build_update_term(update_term_hobj_t *p) {
  return new_update_term(p->tbl, p->fun, p->nargs, p->arg, p->newval);
}

static term_t build_distinct_term(distinct_term_hobj_t *p) {
  return new_distinct_term(p->tbl, p->nargs, p->arg);
}

static term_t build_forall_term(forall_term_hobj_t *p) {
  return new_forall_term(p->tbl, p->nvars, p->var, p->body);
}

static term_t build_arith_buffer_term(arith_buffer_hobj_t *p) {
  polynomial_t *poly;
  poly = arith_buffer_getpoly(p->b);
  if (p->tag == ARITH_TERM) {
    return new_arith_term(p->tbl, poly);
  } else {
    return new_arith_atom(p->tbl, p->tag, poly);
  }
}

static term_t build_monarray_term(monarray_hobj_t *p) {
  polynomial_t *poly;
  poly = monarray_getpoly(p->mono, p->nterms);
  if (p->tag == ARITH_TERM) {
    return new_arith_term(p->tbl, poly);
  } else {
    return new_arith_atom(p->tbl, p->tag, poly);
  }
}

static term_t build_arith_bineq_atom(arith_bineq_hobj_t *p) {
  return new_arith_bineq_atom(p->tbl, p->left, p->right);
}

static term_t build_bvarith_term(bvarith_hobj_t *p) {
  return new_bvarith_term(p->tbl, bvarith_buffer_get_expr(p->b));
}

static term_t build_bvlogic_term(bvlogic_hobj_t *p) {
  return new_bvlogic_term(p->tbl, bvlogic_buffer_get_expr(p->b));
}

static term_t build_bvconst_term(bvconst_hobj_t *p) {
  return new_bvconst_term(p->tbl, p->nbits, p->bits);
}

static term_t build_bvatom(bvatom_hobj_t *p) {
  return new_bvatom(p->tbl, p->tag, p->left, p->right);
}

static term_t build_bvapply_term(bvapply_term_hobj_t *p) {
  return new_bvapply_term(p->tbl, p->op, p->arg0, p->arg1);
}


/*
 * Global hash objects
 */
static constant_term_hobj_t constant_hobj = {
  { (hobj_hash_t) hash_constant_term, (hobj_eq_t) equal_constant_term, 
    (hobj_build_t) build_constant_term },
  NULL,
  0, 0,
};

static variable_hobj_t variable_hobj = {
  { (hobj_hash_t) hash_variable, (hobj_eq_t) equal_variable, 
    (hobj_build_t) build_variable },
  NULL,
  0, 0,
};

static ite_term_hobj_t ite_hobj = {
  { (hobj_hash_t) hash_ite_term, (hobj_eq_t) equal_ite_term, 
    (hobj_build_t) build_ite_term },
  NULL,
  0, 0, 0, 0,
};

static eq_term_hobj_t eq_hobj = {
  { (hobj_hash_t) hash_eq_term, (hobj_eq_t) equal_eq_term,
    (hobj_build_t) build_eq_term },
  NULL,
  0, 0,
};

static app_term_hobj_t app_hobj = {
  { (hobj_hash_t) hash_app_term, (hobj_eq_t) equal_app_term,
    (hobj_build_t) build_app_term },
  NULL,
  0, 0, NULL,
};

static or_term_hobj_t or_hobj = {
  { (hobj_hash_t) hash_or_term, (hobj_eq_t) equal_or_term,
    (hobj_build_t) build_or_term },
  NULL,
  0, NULL,
};

static not_term_hobj_t not_hobj = {
  { (hobj_hash_t) hash_not_term, (hobj_eq_t) equal_not_term,
    (hobj_build_t) build_not_term },
  NULL,
  0,
};

static tuple_term_hobj_t tuple_hobj = {
  { (hobj_hash_t) hash_tuple_term, (hobj_eq_t) equal_tuple_term,
    (hobj_build_t) build_tuple_term },
  NULL,
  0, NULL,
};

static select_term_hobj_t select_hobj = {
  { (hobj_hash_t) hash_select_term, (hobj_eq_t) equal_select_term,
    (hobj_build_t) build_select_term },
  NULL,
  0, 0,
};

static update_term_hobj_t update_hobj = {
  { (hobj_hash_t) hash_update_term, (hobj_eq_t) equal_update_term,
    (hobj_build_t) build_update_term },
  NULL,
  0, 0, 0, NULL,
};

static distinct_term_hobj_t distinct_hobj = {
  { (hobj_hash_t) hash_distinct_term, (hobj_eq_t) equal_distinct_term,
    (hobj_build_t) build_distinct_term },
  NULL,
  0, NULL,
};

static forall_term_hobj_t forall_hobj = {
  { (hobj_hash_t) hash_forall_term, (hobj_eq_t) equal_forall_term,
    (hobj_build_t) build_forall_term },
  NULL,
  0, 0, NULL,
};

static arith_buffer_hobj_t arith_buffer_hobj = {
  { (hobj_hash_t) hash_arith_buffer_term, (hobj_eq_t) equal_arith_buffer_term,
    (hobj_build_t) build_arith_buffer_term },
  NULL,
  NULL, UNUSED_TERM,
};

static monarray_hobj_t monarray_hobj = {
  { (hobj_hash_t) hash_monarray_term, (hobj_eq_t) equal_monarray_term,
    (hobj_build_t) build_monarray_term },
  NULL,
  NULL, 0, UNUSED_TERM,
};

static arith_bineq_hobj_t arith_bineq_hobj = {
  { (hobj_hash_t) hash_arith_bineq_atom, (hobj_eq_t) equal_arith_bineq_atom,
    (hobj_build_t) build_arith_bineq_atom },
  NULL,
  0, 0,
};

static bvarith_hobj_t bvarith_hobj = {
  { (hobj_hash_t) hash_bvarith_term, (hobj_eq_t) equal_bvarith_term,
    (hobj_build_t) build_bvarith_term },
  NULL,
  NULL,
};

static bvlogic_hobj_t bvlogic_hobj = {
  { (hobj_hash_t) hash_bvlogic_term, (hobj_eq_t) equal_bvlogic_term,
    (hobj_build_t) build_bvlogic_term },
  NULL,
  NULL,
};

static bvconst_hobj_t bvconst_hobj = {
  { (hobj_hash_t) hash_bvconst_term, (hobj_eq_t) equal_bvconst_term,
    (hobj_build_t) build_bvconst_term },
  NULL,
  0, NULL,
};

static bvatom_hobj_t bvatom_hobj = {
  { (hobj_hash_t) hash_bvatom, (hobj_eq_t) equal_bvatom,
    (hobj_build_t) build_bvatom },
  NULL,
  0, 0, UNUSED_TERM,
};

static bvapply_term_hobj_t bvapply_term_hobj = {
  { (hobj_hash_t) hash_bvapply_term, (hobj_eq_t) equal_bvapply_term,
    (hobj_build_t) build_bvapply_term },
  NULL,
  0, 0, UNUSED_TERM,
};



/****************
 *  MODULE API  *
 ***************/

/*
 * Initialize table with initial size = n.
 * Create the built-in constants.
 */
void init_term_table(term_table_t *table, uint32_t n, type_table_t *ttbl, 
		     arithvar_manager_t *arith_m, bv_var_manager_t *bv_m) {
  term_table_init(table, n, ttbl, arith_m, bv_m);
  add_primitive_terms(table);
}

/*
 * Delete table
 */
void delete_term_table(term_table_t *table) {
  uint32_t i;

  // delete all descriptors
  for (i=0; i<table->nelems; i++) {
    switch (table->kind[i]) {
    case UNUSED_TERM:
    case CONSTANT_TERM:
    case UNINTERPRETED_TERM:
    case VARIABLE:
    case NOT_TERM:
      break;

    case ITE_TERM:
    case EQ_TERM:
    case APP_TERM:
    case OR_TERM:
    case TUPLE_TERM:
    case SELECT_TERM:
    case UPDATE_TERM:
    case DISTINCT_TERM:
    case FORALL_TERM:
      safe_free(table->desc[i].ptr);
      break;

    case ARITH_TERM:
    case ARITH_EQ_ATOM:
    case ARITH_GE_ATOM:
      free_polynomial(table->desc[i].ptr);
      break;

    case ARITH_BINEQ_ATOM:
    case BV_LOGIC_TERM:
    case BV_ARITH_TERM:
    case BV_CONST_TERM:
    case BV_EQ_ATOM:
    case BV_GE_ATOM:
    case BV_SGE_ATOM:
    case BV_APPLY_TERM:
      safe_free(table->desc[i].ptr);
      break;
    }

    // delete theory variable if any
    if (table->theory_var[i] != null_theory_var) {
      delete_theory_var(table, i);
    }

    // decrement ref counter on table->name[i]
    if (table->name[i] != NULL) {
      string_decref(table->name[i]);
    }
  }

  safe_free(table->kind);
  safe_free(table->type);
  safe_free(table->desc);
  safe_free(table->name);
  safe_free(table->theory_var);
  delete_bitvector(table->root);
  delete_int_htbl(&table->htbl);
  delete_stbl(&table->stbl);
  safe_free(table->buffer);

  table->kind = NULL;
  table->type = NULL;
  table->desc = NULL;
  table->name = NULL;
  table->root = NULL;
  table->buffer = NULL;
}



/***********************
 *  TERM CONSTRUCTION  *
 **********************/

/*
 * Construct constant term of given type and index.
 */
term_t constant_term(term_table_t *table, type_t tau, int32_t index) {
  constant_hobj.tbl = table;
  constant_hobj.tau = tau;
  constant_hobj.idx = index;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &constant_hobj);
}

/*
 * Construct variable of type tau and given index
 */
term_t variable(term_table_t *table, type_t tau, int32_t index) {
  variable_hobj.tbl = table;
  variable_hobj.tau = tau;
  variable_hobj.idx = index;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &variable_hobj);
}

/*
 * Composite terms
 */
term_t ite_term(term_table_t *table, term_t cond, term_t then_term, term_t else_term, type_t tau) {
  assert(tau == super_type(table->type_table, term_type(table, then_term), 
			   term_type(table, else_term)));

  ite_hobj.tbl = table;
  ite_hobj.cond = cond;
  ite_hobj.then_arg = then_term;
  ite_hobj.else_arg = else_term;
  ite_hobj.type = tau;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &ite_hobj);
}

term_t eq_term(term_table_t *table, term_t left, term_t right) {
  eq_hobj.tbl = table;
  eq_hobj.left = left;
  eq_hobj.right = right;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &eq_hobj);
}

term_t app_term(term_table_t *table, term_t fun, int32_t n, term_t arg[]) {
  app_hobj.tbl = table;
  app_hobj.nargs = n;
  app_hobj.fun = fun;
  app_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &app_hobj);
}

term_t or_term(term_table_t *table, int32_t n, term_t arg[]) {
  or_hobj.tbl = table;
  or_hobj.nargs = n;
  or_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &or_hobj);
}

term_t not_term(term_table_t *table, term_t arg) {
  not_hobj.tbl = table;
  not_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &not_hobj);
}

term_t tuple_term(term_table_t *table, int32_t n, term_t arg[]) {
  tuple_hobj.tbl = table;
  tuple_hobj.nargs = n;
  tuple_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &tuple_hobj);
}

term_t select_term(term_table_t *table, int32_t index, term_t tuple) {
  select_hobj.tbl = table;
  select_hobj.idx = index;
  select_hobj.arg = tuple;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &select_hobj);  
}

term_t update_term(term_table_t *table, term_t fun, int32_t n, term_t arg[], term_t new_v) {
  update_hobj.tbl = table;
  update_hobj.fun = fun;
  update_hobj.newval = new_v;
  update_hobj.nargs = n;
  update_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &update_hobj);
}

term_t distinct_term(term_table_t *table, int32_t n, term_t arg[]) {
  distinct_hobj.tbl = table;
  distinct_hobj.nargs = n;
  distinct_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &distinct_hobj);
}

term_t forall_term(term_table_t *table, int32_t n, term_t var[], term_t body) {
  forall_hobj.tbl = table;
  forall_hobj.body = body;
  forall_hobj.nvars = n;
  forall_hobj.var = var;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &forall_hobj);
}


/*
 * Arithmetic terms and atoms
 */
term_t arith_object_from_buffer(term_table_t *table, term_kind_t tag, arith_buffer_t *b) {
  arith_buffer_hobj.tbl = table;
  arith_buffer_hobj.b = b;
  arith_buffer_hobj.tag = tag;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &arith_buffer_hobj);
}

term_t arith_object_from_monarray(term_table_t *table, term_kind_t tag, monomial_t *p, int32_t n) {
  monarray_hobj.tbl = table;
  monarray_hobj.mono = p;
  monarray_hobj.nterms = n;
  monarray_hobj.tag = tag;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &monarray_hobj);
}

term_t arith_bineq_atom(term_table_t *table, term_t l, term_t r) {
  arith_bineq_hobj.tbl = table;
  arith_bineq_hobj.left = l;
  arith_bineq_hobj.right = r;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &arith_bineq_hobj);
}


/*
 * Bitvector terms and atoms
 */
term_t bvarith_term(term_table_t *table, bvarith_buffer_t *b) {
  bvarith_hobj.tbl = table;
  bvarith_hobj.b = b;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvarith_hobj);
}

term_t bvlogic_term(term_table_t *table, bvlogic_buffer_t *b) {
  bvlogic_hobj.tbl = table;
  bvlogic_hobj.b = b;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvlogic_hobj);
}

term_t bvconst_term(term_table_t *table, int32_t n, uint32_t *b) {
  bvconst_hobj.tbl = table;
  bvconst_hobj.nbits = n;
  bvconst_hobj.bits = b;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvconst_hobj);
}

term_t bitvector_atom(term_table_t *table, term_kind_t tag, term_t l, term_t r) {
  bvatom_hobj.tbl = table;
  bvatom_hobj.tag = tag;
  bvatom_hobj.left = l;
  bvatom_hobj.right = r;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvatom_hobj);
}

term_t bvapply_term(term_table_t *table, uint32_t op, term_t l, term_t r) {
  bvapply_term_hobj.tbl = table;
  bvapply_term_hobj.arg0 = l;
  bvapply_term_hobj.arg1 = r;
  bvapply_term_hobj.op = op;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvapply_term_hobj);
}


/*
 * Hash code of terms (same as hash_constant_term to hash_bvatom)
 */
static uint32_t hash_constant(type_t tau, int32_t idx) {
  return jenkins_hash_pair(tau, idx, 0x19ef312c);
}

static uint32_t hash_var(type_t tau, int32_t idx) {
  return jenkins_hash_pair(tau, idx, 0x83891aef);
}

static uint32_t hash_ite(ite_term_t *p) {
  return jenkins_hash_triple(p->cond, p->then_arg, p->else_arg, 0x9f34197a);
}

static uint32_t hash_eq(eq_term_t *p) {
  return jenkins_hash_pair(p->left, p->right, 0x78d2bae1);
}

static uint32_t hash_app(app_term_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray(p->nargs, p->arg);
  return jenkins_hash_pair(p->fun, 0, h);
}

static uint32_t hash_or(or_term_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0xf82bf286);
}

static uint32_t hash_not(term_t arg) {
  return jenkins_hash_pair(arg, 0, 0x183b42e6);
}

static uint32_t hash_tuple(tuple_term_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0xae7bd466);
}

static uint32_t hash_select(select_term_t *p) {
  return jenkins_hash_pair(p->arg, p->idx, 0x4137bee9);
}

static uint32_t hash_update(update_term_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray_var(p->nargs, p->arg, 0x378a121a);
  return jenkins_hash_pair(p->fun, p->newval, h);
}

static uint32_t hash_distinct(distinct_term_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0x783426);
}

static uint32_t hash_forall(forall_term_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray_var(p->nvars, p->var, 0x9172ea9f);
  return jenkins_hash_pair(p->body, 0, h);
}

static uint32_t hash_arith(polynomial_t *p, term_kind_t tag) {
  uint32_t h;
  h = hash_monarray(p->mono);
  return jenkins_hash_pair(tag, 0, h);
}

static uint32_t hash_arith_bineq(arith_bineq_t *p) {
  return jenkins_hash_pair(p->left, p->right, 0x761bedaf);
}

static uint32_t hash_bvarith(bvarith_expr_t *p) {
  return bvarith_expr_hash(p);
}

static uint32_t hash_bvlogic(bvlogic_expr_t *p) {
  return bvlogic_expr_hash(p);
}

static uint32_t hash_bvconst(bvconst_term_t *p) {
  int32_t k;
  k = (p->nbits + 31) >> 5; // number of 32-bit words 
  return jenkins_hash_intarray_var(k, (int32_t *) p->bits, 0x71837ae4);
}

static uint32_t hash_bvatm(bv_atom_t *p, term_kind_t tag) {
  return jenkins_hash_triple(p->left, p->right, tag, 0x7aaf3277);
}

static uint32_t hash_bvterm(bvapply_term_t *p) {
  return jenkins_hash_triple(p->op, p->arg0, p->arg1, 0x8317ed8);
}

/*
 * Remove a term t from the hash-consing table
 */
static void erase_hcons_record(term_table_t *table, term_t i) {
  uint32_t k; // hash code

  switch (table->kind[i]) {
  case CONSTANT_TERM:
    k = hash_constant(table->type[i], table->desc[i].integer);
    break;

  case VARIABLE:
    k = hash_var(table->type[i], table->desc[i].integer);
    break;
    
  case NOT_TERM:
    k = hash_not(table->desc[i].integer);
    break;

  case ITE_TERM:
    k = hash_ite(table->desc[i].ptr);
    break;

  case EQ_TERM:
    k = hash_eq(table->desc[i].ptr);
    break;

  case APP_TERM:
    k = hash_app(table->desc[i].ptr);
    break;

  case OR_TERM:
    k = hash_or(table->desc[i].ptr);
    break;

  case TUPLE_TERM:
    k = hash_tuple(table->desc[i].ptr);
    break;

  case SELECT_TERM:
    k = hash_select(table->desc[i].ptr);
    break;

  case UPDATE_TERM:
    k = hash_update(table->desc[i].ptr);
    break;

  case DISTINCT_TERM:
    k = hash_distinct(table->desc[i].ptr);
    break;

  case FORALL_TERM:
    k = hash_forall(table->desc[i].ptr);
    break;

  case ARITH_TERM:
    k = hash_arith(table->desc[i].ptr, ARITH_TERM);
    break;

  case ARITH_EQ_ATOM:
    k = hash_arith(table->desc[i].ptr, ARITH_EQ_ATOM);
    break;

  case ARITH_GE_ATOM:
    k = hash_arith(table->desc[i].ptr, ARITH_GE_ATOM);
    break;

  case ARITH_BINEQ_ATOM:
    k = hash_arith_bineq(table->desc[i].ptr);
    break;

  case BV_LOGIC_TERM:
    k = hash_bvlogic(table->desc[i].ptr);
    break;

  case BV_ARITH_TERM:
    k = hash_bvarith(table->desc[i].ptr);
    break;

  case BV_CONST_TERM:
    k = hash_bvconst(table->desc[i].ptr);
    break;

  case BV_EQ_ATOM:
    k = hash_bvatm(table->desc[i].ptr, BV_EQ_ATOM);
    break;

  case BV_GE_ATOM:
    k = hash_bvatm(table->desc[i].ptr, BV_GE_ATOM);
    break;

  case BV_SGE_ATOM:
    k = hash_bvatm(table->desc[i].ptr, BV_SGE_ATOM);
    break;

  case BV_APPLY_TERM:
    k = hash_bvterm(table->desc[i].ptr);
    break;

  default:
    return;
  }

  int_htbl_erase_record(&table->htbl, k, i);
}


/****************
 *  TERM NAMES  *
 ***************/

/*
 * Assign name to term t
 * - name must be a string with refcounter 
 */
void set_term_name(term_table_t *table, term_t t, char *name) {
  if (table->name[t] == NULL) {
    table->name[t] = name;
    string_incref(name);
  }
  stbl_add(&table->stbl, name, t);
  string_incref(name);
}


/*
 * Get term of the given name
 */
term_t get_term_by_name(term_table_t *table, char *name) {
  term_t t;

  t = stbl_find(&table->stbl, name);
  return (t >= 0) ? t : NULL_TERM;
}


/*
 * Remove term name
 */
void remove_term_name(term_table_t *table, char *name) {
  stbl_remove(&table->stbl, name);
}


/**********************
 *  THEORY VARIABLES  *
 *********************/
/*
 * Return the arithmetic variable associated with term t.
 * - t must be an arithmetic term (type = int or real)
 * - a new variable if allocated in table->arith_manager if t 
 *   does not have a variable attached already.
 * - otherwise, table->theory_var[t] is returned.
 */
int32_t get_arithmetic_variable(term_table_t *table, term_t t) {
  int32_t v;
  bool integer;

  assert(is_arithmetic_term(table, t));

  v = table->theory_var[t];
  if (v == null_theory_var) {
    integer = is_integer_type(table->type[t]);
    v = arithvar_manager_new_var(table->arith_manager, integer, t);
    table->theory_var[t] = v;
  }
  return v;
}


/*
 * Return the bitvector variable associated with term t
 * - t must be a bitvector term
 * - a new variable is allocated in table->bv_manager t does
 *   not have an existing theory variable, otherwise that variable
 *   is returned.
 */
int32_t get_bitvector_variable(term_table_t *table, term_t t) {
  int32_t v;
  int32_t nbits;

  assert(is_bitvector_term(table, t));

  v = table->theory_var[t];
  if (v == null_theory_var) {
    nbits = bv_type_size(table->type_table, table->type[t]);
    v = bv_var_manager_new_var(table->bv_manager, nbits, t);
    table->theory_var[t] = v;
  }
  return v;
}



/***********************
 * GARBAGE COLLECTION  *
 **********************/

/*
 * Support for type-table garbage collection
 * - mark all types in the term table to prevent them from
 *   being removed from the type table
 * - must be called only via the gc_notifier attached to the type
 *   table table->type_table.
 */
void mark_term_types(term_table_t *table) {
  type_table_t *tbl;
  term_t i;
  int32_t n;

  tbl = table->type_table;
  n = table->nelems;
  for (i=0; i<n; i++) {
    if (table->kind[i] != UNUSED_TERM) {
      gc_mark_type(tbl, table->type[i]);
    }
  }
}


/*
 * Term garbage collection: terms with root_flag set are not deleted.
 */
void set_root_term_flag(term_table_t *table, term_t i) {
  set_bit(table->root, i);
}

void clr_root_term_flag(term_table_t *table, term_t i) {
  clr_bit(table->root, i);
}



/*
 * Marking for garbage collection of terms
 * - mark_queue = bitvector. One bit per term
 *   if mark_queue[t] = 0 then t will be deleted otherwise it
 *   will be kept.
 * - q = integer queue for processing subterms (breadth-first)
 */

// mark t if it's not already marked and add it to the queue
static void gc_mark_push_term(int_queue_t *q, byte_t *mark, term_t t) {
  if (! tst_bit(mark, t)) {
    set_bit(mark, t);
    int_queue_push(q, t);
  }
}

// same thing for terms a[0] ... a[n-1]
static void gc_mark_push_array(int_queue_t *q, byte_t *mark, term_t *a, int32_t n) {
  int32_t i;

  for (i=0; i<n; i++) {
    gc_mark_push_term(q, mark, a[i]);
  }
}

// mark components of a term
static inline void gc_mark_ite(int_queue_t *q, byte_t *mark, ite_term_t *ite) {
  gc_mark_push_term(q, mark, ite->cond);
  gc_mark_push_term(q, mark, ite->then_arg);
  gc_mark_push_term(q, mark, ite->else_arg);
}

static inline void gc_mark_eq(int_queue_t *q, byte_t *mark, eq_term_t *eq) {
  gc_mark_push_term(q, mark, eq->left);
  gc_mark_push_term(q, mark, eq->right);  
}

static inline void gc_mark_app(int_queue_t *q, byte_t *mark, app_term_t *app) {
  gc_mark_push_term(q, mark, app->fun);
  gc_mark_push_array(q, mark, app->arg, app->nargs);
}

static inline void gc_mark_or(int_queue_t *q, byte_t *mark, or_term_t *or) {
  gc_mark_push_array(q, mark, or->arg, or->nargs);
}

static inline void gc_mark_tuple(int_queue_t *q, byte_t *mark, tuple_term_t *tuple) {
  gc_mark_push_array(q, mark, tuple->arg, tuple->nargs);
}

static inline void gc_mark_select(int_queue_t *q, byte_t *mark, select_term_t *select) {
  gc_mark_push_term(q, mark, select->arg);
}

static inline void gc_mark_update(int_queue_t *q, byte_t *mark, update_term_t *update) {
  gc_mark_push_term(q, mark, update->fun);
  gc_mark_push_term(q, mark, update->newval);
  gc_mark_push_array(q, mark, update->arg, update->nargs);
}

static inline void gc_mark_distinct(int_queue_t *q, byte_t *mark, distinct_term_t *distinct) {
  gc_mark_push_array(q, mark, distinct->arg, distinct->nargs);
}

static inline void gc_mark_forall(int_queue_t *q, byte_t *mark, forall_term_t *forall) {
  gc_mark_push_array(q, mark, forall->var, forall->nvars);
  gc_mark_push_term(q, mark, forall->body);
}

static inline void gc_mark_bvatom(int_queue_t *q, byte_t *mark, bv_atom_t *atom) {
  gc_mark_push_term(q, mark, atom->left);
  gc_mark_push_term(q, mark, atom->right);  
}

static inline void gc_mark_bvterm(int_queue_t *q, byte_t *mark, bvapply_term_t *bvt) {
  gc_mark_push_term(q, mark, bvt->arg0);
  gc_mark_push_term(q, mark, bvt->arg1);  
}


/*
 * Mark terms reachable from a polynomial
 * - every variable x in the monomial array that has degree 1 represents a term
 *   in the term table. That term is marked.
 */
static void gc_mark_polynomial(int_queue_t *q, byte_t *mark, polynomial_manager_t *m, polynomial_t *p) {
  int32_t i, n;
  arith_var_t x;

  n = p->nterms;
  for (i=0; i<n; i++) {
    x = p->mono[i].var;
    if (polymanager_var_is_primitive(m, x)) {
      gc_mark_push_term(q, mark, polymanager_var_index(m, x));
    }
  }
}

/*
 * Subterms of an arithmetic equality
 */
static inline void gc_mark_arith_bineq(int_queue_t *q, byte_t *mark, arith_bineq_t *eq) {
  gc_mark_push_term(q, mark, eq->left);
  gc_mark_push_term(q, mark, eq->right);  
}


/*
 * Mark terms reachable from a bitvector arithmetic expression
 * - every variable x in the monomial array that has degree 1 represents a term
 *   in the term table. That term is marked.
 */
static void gc_mark_bvarith_expr(int_queue_t *q, byte_t *mark, polynomial_manager_t *m, bvarith_expr_t *e) {
  int32_t i, n;
  bv_var_t x;

  n = e->nterms;
  for (i=0; i<n; i++) {
    x = e->mono[i].var;
    if (polymanager_var_is_primitive(m, x)) {
      gc_mark_push_term(q, mark, polymanager_var_index(m, x));
    }
  }
}


/*
 * Mark terms reachable from a bdd array:
 * - bm: auxiliary marker to avoid visiting the same node twice
 * - the term marking is done by the callback function attached to 
 *   bm->marker (i.e., mark_term_from_bit_expr)
 */
static void gc_mark_bvlogic_expr(term_bit_marker_t *bm, bvlogic_expr_t *bv) {
  uint32_t i, n;

  n = bv->nbits;
  for (i=0; i<n; i++) {
    bit_marker_visit(&bm->marker, node_of_bit(bv->bit[i]));
  }
}


/*
 * Mark term t and all its subterms
 * - must be called only after table->gc_mark and table->gc_mark_queue
 * have been initialized (i.e., within a gc_notifier).
 */
void gc_mark_term(term_table_t *table, term_t t) {
  int_queue_t *q;
  byte_t *mark;

  assert(table->gc_mark != NULL);
  assert(table->gc_mark_queue != NULL);

  mark = table->gc_mark;
  if (! tst_bit(mark, t)) {
    set_bit(mark, t);
    q = table->gc_mark_queue;
    for (;;) {
      switch(table->kind[t]) {
      case UNUSED_TERM:
      case CONSTANT_TERM:    
      case UNINTERPRETED_TERM:
      case VARIABLE:
	break;
      case NOT_TERM:
	gc_mark_push_term(q, mark, table->desc[t].integer);
	break;
      case ITE_TERM:
	gc_mark_ite(q, mark, table->desc[t].ptr);
	break;
      case EQ_TERM:
	gc_mark_eq(q, mark, table->desc[t].ptr);
	break;
      case APP_TERM:
	gc_mark_app(q, mark, table->desc[t].ptr);
	break;
      case OR_TERM:
	gc_mark_or(q, mark, table->desc[t].ptr);
	break;
      case TUPLE_TERM:
	gc_mark_tuple(q, mark, table->desc[t].ptr);
	break;
      case SELECT_TERM:
	gc_mark_select(q, mark, table->desc[t].ptr);
	break;
      case UPDATE_TERM:
	gc_mark_update(q, mark, table->desc[t].ptr);
	break;
      case DISTINCT_TERM:
	gc_mark_distinct(q, mark, table->desc[t].ptr);
	break;
      case FORALL_TERM:
	gc_mark_forall(q, mark, table->desc[t].ptr);
	break;

      case ARITH_TERM:
      case ARITH_EQ_ATOM:
      case ARITH_GE_ATOM:
	gc_mark_polynomial(q, mark, &table->arith_manager->pm, table->desc[t].ptr);
	break;
      case ARITH_BINEQ_ATOM:
	gc_mark_arith_bineq(q, mark, table->desc[t].ptr);
	break;
      case BV_LOGIC_TERM:
	gc_mark_bvlogic_expr(table->gc_bit_marker, table->desc[t].ptr);
	break;
      case BV_ARITH_TERM:
	gc_mark_bvarith_expr(q, mark, &table->bv_manager->pm, table->desc[t].ptr);
	break;

      case BV_CONST_TERM:
	break;
      case BV_EQ_ATOM:
      case BV_GE_ATOM:
      case BV_SGE_ATOM:
	gc_mark_bvatom(q, mark, table->desc[t].ptr);
	break;
      case BV_APPLY_TERM:
	gc_mark_bvterm(q, mark, table->desc[t].ptr);
	break;
      }

      if (int_queue_is_empty(q)) break;
      t = int_queue_pop(q);
    }
  }
}





/*
 * Marker function: callback in table->gc_bit_marker.
 *
 * Mark term that may be reachable from the bit-variable of node:
 * - that variable may be attached to a bit-vector variable v
 * - v may be attached to a term t (if v is a primitive variable).
 * Object o store the following data:
 * - nodes: node tables for all bvlogic_expr of the table
 * - pm: bitvector variable manager for all bvlogic and bvarith expressions
 * - mark, q: term marking and queue 
 * 
 * - node is the id of a node reachable from a bvlogic_expr term
 */
static void mark_term_from_bit_expr(void *o, node_t node) {
  term_bit_marker_t *p;
  int32_t v;

  p = (term_bit_marker_t *) o;
  if (is_variable_node(p->nodes, node)) {
    v = bv_var_of_node(p->nodes, node);
    if (v >= 0 && polymanager_var_is_primitive(p->pm, v)) {
      gc_mark_push_term(p->q, p->mark, polymanager_var_index(p->pm, v));
    }
  }
}



/*
 * Mark all terms with root_flag set and all terms accessible from the symbol table. 
 */
static void mark_live_terms(term_table_t *table) {
  stbl_t *sym_table;
  stbl_bank_t *b;
  stbl_rec_t *r;
  term_t i;
  uint32_t k;

  // mark terms accessible from the symbol table
  sym_table = &table->stbl;
  k = sym_table->free_idx;
  for (b = sym_table->bnk; b != NULL; b = b->next) {
    for (r = b->block + k; r < b->block + STBL_BANK_SIZE; r ++) {      
      if (r->string != NULL) {
	i = r->value;
	gc_mark_term(table, i);
      }
    }
    k = 0;
  }

  // mark terms with root_flag == 1
  for (i=0; i<table->nelems; i++) {
    if (table->kind[i] != UNUSED_TERM && tst_bit(table->root, i)) {
      gc_mark_term(table, i);
    }
  }  
}


/*
 * Garbage collection
 */
void term_table_garbage_collection(term_table_t *table) {
  int32_t n;
  term_t i;
  int_queue_t queue;
  byte_t *mark;
  term_bit_marker_t bit_marker;
  node_table_t *nodes;

  // initialize gc_mark, mark_queue, bdd_marker
  init_int_queue(&queue, 0);
  n = table->nelems;
  mark = allocate_bitvector(n);
  clear_bitvector(mark, n);
  nodes = table->bv_manager->bm;

  init_bit_marker(&bit_marker.marker, nodes, mark_term_from_bit_expr);
  bit_marker.nodes = nodes;
  bit_marker.pm = &table->bv_manager->pm;
  bit_marker.mark = mark;
  bit_marker.q = &queue;

  table->gc_mark = mark;
  table->gc_mark_queue = &queue;
  table->gc_bit_marker = &bit_marker;

  // mark root terms and all reachable subterms
  gc_mark_term(table, false_term_id);
  gc_mark_term(table, true_term_id);
  mark_live_terms(table);

  table->gc_notifier(table);

  // delete all unmarked terms
  for (i=0; i<n; i++) {
    if (! tst_bit(mark, i)) {
      erase_hcons_record(table, i);
      erase_term(table, i);
    }
  }

  // delete the dead nodes in the bit node table
  node_table_garbage_collection(nodes);

  // cleanup
  table->gc_mark = NULL;
  table->gc_mark_queue = NULL;
  table->gc_bit_marker = NULL;
  delete_bitvector(mark);
  delete_int_queue(&queue);
}

#endif
