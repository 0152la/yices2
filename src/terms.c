/*
 * INTERNAL TERM REPRESENTATION AND HASH CONSING
 */

/*
 * The internal terms include:
 * 1) constants:
 *    - constants of uninterpreted/scalar
 *    - global uninterpreted constants 
 * 2) generic terms
 *    - ite c t1 t2
 *    - eq t1 t2
 *    - apply f t1 ... t_n
 *    - mk-tuple t1 ... t_n
 *    - select i tuple
 *    - update f t1 ... t_n v
 *    - distinct t1 ... t_n
 * 3) variables and quantifiers
 *    - variables are identified by their type and an integer index.
 *    - quantified formulas are of the form (forall v_1 ... v_n term)
 *      where each v_i is a variable
 * 4) boolean operators
 *    - or t1 ... t_n
 *    - xor t1 ... t_n
 *    - bit i u (extract bit i of a bitvector term u)
 * 6) arithmetic terms and atoms
 *    - terms are either rational constants, power products, or 
 *      polynomials with rational coefficients
 *    - atoms are either of the form (p == 0) or (p >= 0)
 *      where p is a polynomial.
 *    - atoms a x - a y == 0 are rewritten to (x = y)
 * 7) bitvector terms and atoms
 *    - bitvector constants
 *    - power products
 *    - polynomials
 *    - bit arrays
 *    - other operations: divisions/shift
 *    - atoms: three binary predicates
 *      bv_eq t1 t2
 *      bv_ge t1 t2 (unsigned comparison: t1 >= t2)
 *      bv_sge t1 t2 (signed comparison: t1 >= t2)
 *
 * Every term is an index t in a global term table,
 * where 0 <= t <= 2^30. The two term occurrences
 * t+ and t- are encoded on 32bits (signed integer) with
 * - bit[31] = sign bit = 0
 * - bits[30 ... 1] = t
 * - bit[0] = polarity bit: 0 means t+, 1 means t-
 *
 * For a boolean term t, the occurrence t+ means p
 * and t- means (not p). All occurrences of a 
 * non-boolean term t are positive.
 * 
 * For every term, we keep:
 * - type[t] (index in the type table)
 * - kind[t] (what kind of term it is)
 * - desc[t] = descriptor that depends on the kind
 *
 * It is possible to attach names to term occurrences (but not directly 
 * to terms). This is required to deal properly with booleans. For example,
 * we want to allow the user to give different names to t and (not t).
 */

#include "memalloc.h"
#include "refcount_strings.h"
#include "hash_functions.h"
#include "bv64_constants.h"

#include "terms.h"



/*
 * Finalizer for term names in the symbol table.
 * All symbols must be generated by the clone function, and have
 * a reference counter (cf. refcount_strings.h).
 */
static void term_name_finalizer(stbl_rec_t *r) {
  string_decref(r->string);
}


/*
 * Initialize table, with initial size n.
 * - ttbl = attached type table.
 * - ptbl = attached power-product table.
 */
static void term_table_init(term_table_t *table, uint32_t n, type_table_t *ttbl, pprod_table_t *ptbl) {
  // abort if n is too large
  if (n > YICES_MAX_TERMS) {
    out_of_memory();
  }

  table->kind = (unsigned char *) safe_malloc(n * sizeof(unsigned char));
  table->type = (type_t *) safe_malloc(n * sizeof(type_t));
  table->desc = (term_desc_t *) safe_malloc(n * sizeof(term_desc_t));
  table->mark = allocate_bitvector(n);

  table->size = n;
  table->nelems = 0;
  table->free_idx = -1; // empty free list

  table->types = ttbl;
  table->pprods = ptbl;

  // initialize hashtable tables with default initial size 
  init_int_htbl(&table->htbl, 0);
  init_stbl(&table->stbl, 0);
  init_ptr_hmap(&table->ntbl, 0);
  init_int_hmap(&table->utbl, 0);

  // attach the name finalizer to stbl
  stbl_set_finalizer(&table->stbl, term_name_finalizer);

  // buffers
  init_ivector(&table->ibuffer, 20);
  init_pvector(&table->pbuffer, 20);
}


/*
 * Extend the table: make it 50% larger
 */
static void term_table_extend(term_table_t *table) {
  uint32_t n;

  n = table->size + 1;
  n += n >> 1;

  // force abort if n is too large
  if (n > YICES_MAX_TERMS) {
    out_of_memory();
  }

  table->kind = (unsigned char *) safe_realloc(table->kind, n * sizeof(unsigned char));
  table->type = (type_t *) safe_realloc(table->type, n * sizeof(type_t));
  table->desc = (term_desc_t *) safe_realloc(table->desc, n * sizeof(term_desc_t));
  table->mark = extend_bitvector(table->mark, n);
  table->size = n;
}




/*
 * TERM ALLOCATION
 */

/*
 * Allocate a new term id
 * - clear its mark. Nothing else is initialized.
 */
static int32_t allocate_term_id(term_table_t *table) {
  int32_t i;

  i = table->free_idx;
  if (i >= 0) {
    table->free_idx = table->desc[i].integer;
  } else {
    i = table->nelems;
    table->nelems ++;
    if (i == table->size) {
      term_table_extend(table);
    }
    assert(i < table->size);
  }
  clr_bit(table->mark, i);

  return i;
}



/*
 * Terms with integer descriptor
 * - tag = kind
 * - tau = type
 * - id = index
 */
static int32_t new_integer_term(term_table_t *table, term_kind_t tag, type_t tau, int32_t id) {
  int32_t i;

  i = allocate_term_id(table);
  table->kind[i] = tag;
  table->type[i] = tau;
  table->desc[i].integer = id;

  return i;
}


/*
 * Terms with pointer descriptor
 * - tag = kind
 * - tau = type
 * - d = descriptor
 */
static int32_t new_ptr_term(term_table_t *table, term_kind_t tag, type_t tau, void *d) {
  int32_t i;

  i = allocate_term_id(table);
  table->kind[i] = tag;
  table->type[i] = tau;
  table->desc[i].ptr = d;

  return i;
}


/*
 * Rational descriptors
 * - tag = kind
 * - tau = type
 * - a = value
 */
static int32_t new_rational_term(term_table_t *table, term_kind_t tag, type_t tau, rational_t *a) {
  int32_t i;

  i = allocate_term_id(table);
  table->kind[i] = tag;
  table->type[i] = tau;
  q_init(&table->desc[i].rational);
  q_set(&table->desc[i].rational, a);

  return i;
}



/*
 * TERM DESCRIPTORS
 */

/*
 * Limit on n when allocating a composite term descriptor of arity n.
 * If n <= MAX_COMPOSITE_TERM_ARITY then we can compute the descriptor
 * size without overflow (on 32bit).
 */
#define MAX_COMPOSITE_TERM_ARITY ((UINT32_MAX-sizeof(composite_term_t))/sizeof(term_t))


/*
 * Generic n-ary term:
 * - n = arity
 * - a[0 ... n-1] = components 
 */
static composite_term_t *new_composite_term(uint32_t n, term_t *a) {
  composite_term_t *d;
  uint32_t j;

  assert(n <= MAX_COMPOSITE_TERM_ARITY);

  d = (composite_term_t *) safe_malloc(sizeof(composite_term_t) + n * sizeof(term_t));
  d->arity = n;
  for (j=0; j<n; j++) {
    d->component[j] = a[j];
  }

  return d;
}


/*
 * Function application
 * - f = function (as a term)
 * - n = arity
 * - a[0 ... n-1] = arguments to f
 */
static composite_term_t *new_app_term(term_t f, uint32_t n, term_t *a) {
  composite_term_t *d;
  uint32_t j;

  assert(n <= MAX_COMPOSITE_TERM_ARITY - 1);

  d = (composite_term_t *) safe_malloc(sizeof(composite_term_t) + (n+1) * sizeof(term_t));
  d->arity = n+1;
  d->component[0] = f;
  for (j=0; j<n; j++) {
    d->component[j + 1] = a[j];
  }

  return d;
}


/*
 * Function update: (update f a[0] ... a[n-1] v)
 */
static composite_term_t *new_update_term(term_t f, uint32_t n, term_t *a, term_t v) {
  composite_term_t *d;
  uint32_t j;

  assert(n <= MAX_COMPOSITE_TERM_ARITY - 2);

  d = (composite_term_t *) safe_malloc(sizeof(composite_term_t) + (n+2) * sizeof(term_t));
  d->arity = n+2;
  d->component[0] = f;
  for (j=0; j<n; j++) {
    d->component[j + 1] = a[j];
  }
  d->component[j + 1] = v;

  return d;
}


/*
 * Select k t: for tuple projection or bitvector selection
 */
static select_term_t *new_select_term(uint32_t k, term_t t) {
  select_term_t *d;

  d = (select_term_t *) safe_malloc(sizeof(select_term_t));
  d->idx = k;
  d->arg = t;

  return d;
}





/*
 * HASH CODES
 */

/*
 * Indexed term defined by (tag, tau, id)
 */
static uint32_t hash_integer_term(term_kind_t tag, type_t tau, int32_t id) {
  return jenkins_hash_triple(tag, tau, id, 0x2839adee);
}

/*
 * Rational term defined by (tag, tau, value)
 */
static uint32_t hash_rational_term(term_kind_t tag, type_t tau, rational_t *a) {
  uint32_t num, den;

  q_hash_decompose(a, &num, &den);
  return jenkins_hash_quad(tag, tau, num, den, 0xf9e34ab9);
}

/*
 * Generic composite term: (tag, arity, arg[0] ... arg[n-1])
 */
static uint32_t hash_composite_term(term_kind_t tag, uint32_t n, term_t *a) {
  uint32_t h;

  h = jenkins_hash_intarray(a, n);
  return jenkins_hash_pair(tag, h, 0x8ede2341);
}


/*
 * Function application: (f, n, a[0] ... a[n-1])
 */
static uint32_t hash_app_term(term_t f, uint32_t n, term_t *a) {
  uint32_t h;

  h = jenkins_hash_intarray(a, n);
  return jenkins_hash_pair(f, h, 0x2a3efb23);
}


/*
 * Function update: (update f a[0] ... a[n-1] v)
 */
static uint32_t hash_update_term(term_t f, uint32_t n, term_t *a, term_t v) {
  uint32_t h;

  h = jenkins_hash_intarray(a, n);
  return jenkins_hash_triple(f, v, h, 0x18abe185);
}


/*
 * Projection/bit selection: (tag, k, t)
 */
static uint32_t hash_select_term(term_kind_t tag, int32_t k, term_t t) {
  return jenkins_hash_triple(tag, k, t, 0x98ab3342);
}


/*
 * Power product: since the pprod-table already does hash consing,
 * a power product r is uniquely identified by its address.
 */
static uint32_t hash_power_product(pprod_t *r) {
  return jenkins_hash_ptr(r);
}


/*
 * For bitvector constant, we can use bvconst_hash defined in bv_constants.c
 */
static inline uint32_t hash_bvconst_term(uint32_t bitsize, uint32_t *bv) {
  return bvconst_hash(bv, bitsize);
}


/*
 * 64bit constants
 */
static inline uint32_t hash_bvconst64_term(uint32_t bitsize, uint64_t v) {
  assert(v == norm64(v, bitsize));
  return jenkins_hash_mix3((uint32_t)(v >> 32), (uint32_t) v, 0xdeadbeef + bitsize);
}





/*
 * HASH CONSING
 */

/*
 * Objects for interfacing with int_hash_table
 * - each object type corresponds to a term kind
 * - it starts with a method descriptor m 
 *   with three fields:
 *     m.hash: hash function
 *     m.eq: check for equality
 *     m.build: construct fresh term
 * - other fields are a term table, and all the 
 *   subcomponents for the term kind.
 * - for an object o, 
 *    o->m.hash(o) = hash code for o
 *    o->m.eq(o, i): check whether o equals term i
 *    o->m.build(o): add o to the term table and return its index
 */

/*
 * Terms with integer id
 * - tag = term kind
 * - tau = type
 * - id
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_kind_t tag;
  type_t tau;
  int32_t id;
} term_integer_hobj_t;

/*
 * Rational terms
 * - tag = term kind
 * - tau = type
 * - a = value
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_kind_t tag;
  type_t tau;
  rational_t *a;
} term_rational_hobj_t;

/*
 * Generic composite
 * - tag = term kind
 * - tau = type
 * - arity = n 
 * - arg = array of n term occurrences
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_kind_t tag;
  type_t tau;
  uint32_t arity;
  term_t *arg;
} composite_hobj_t;

/*
 * Function application
 * - f = function
 * - n = number of arguments
 * - arg = array of n arguments
 * - the type is not needed, it's derived from f's type
 */ 
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_t f;
  uint32_t n;
  term_t *arg;
} app_term_hobj_t;


/*
 * Function update
 * - tau = result type
 * - f = function
 * - n = number of arguments
 * - arg = array of n arguments
 * - v = new value
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  term_t f;
  term_t v;
  uint32_t n;  
  term_t *arg;
} update_term_hobj_t;


/*
 * Select term 
 * - tag = term kind
 * - tau = type
 * - k = index in projection/bitselect
 * - arg = term
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_kind_t tag;
  type_t tau;
  uint32_t k;
  term_t arg;
} select_term_hobj_t;


/*
 * Power product
 * - tau = type
 * - r = power product
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  pprod_t *r;
} pprod_term_hobj_t;



/*
 * Polynomial and arithmetic atoms.
 * - a polynomial is constructed from a buffer b
 *   and an array of term indices v
 * - tag = term kind (can be ARITH_TERM or ARITH_EQ_ATOM or ARITH_GE_ATOM)
 * - tau = can be int or real or bool
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  term_kind_t tag;
  type_t tau;
  arith_buffer_t *b;
  int32_t *v;
} poly_term_hobj_t;


/*
 * Bit-vector polynomials
 * - tau = type
 */
typedef struct {
  int_hobj_t m;
  term_table_t *tbl;
  type_t tau;
  bvarith_buffer_t *b;
  int32_t *v;
} bvpoly_term_hobj_t;






#if 0

/*
 * Hash functions
 */
static uint32_t hash_constant_term(constant_term_hobj_t *p) {
  return jenkins_hash_pair(p->tau, p->idx, 0x19ef312c);
}

static uint32_t hash_variable(variable_hobj_t *p) {
  return jenkins_hash_pair(p->tau, p->idx, 0x83891aef);
}

static uint32_t hash_ite_term(ite_term_hobj_t *p) {
  return jenkins_hash_triple(p->cond, p->then_arg, p->else_arg, 0x9f34197a);
}

static uint32_t hash_eq_term(eq_term_hobj_t *p) {
  return jenkins_hash_pair(p->left, p->right, 0x78d2bae1);
}

static uint32_t hash_app_term(app_term_hobj_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray(p->nargs, p->arg);
  return jenkins_hash_pair(p->fun, 0, h);
}

static uint32_t hash_or_term(or_term_hobj_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0xf82bf286);
}

static uint32_t hash_not_term(not_term_hobj_t *p) {
  return jenkins_hash_pair(p->arg, 0, 0x183b42e6);
}

static uint32_t hash_tuple_term(tuple_term_hobj_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0xae7bd466);
}

static uint32_t hash_select_term(select_term_hobj_t *p) {
  return jenkins_hash_pair(p->arg, p->idx, 0x4137bee9);
}

static uint32_t hash_update_term(update_term_hobj_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray_var(p->nargs, p->arg, 0x378a121a);
  return jenkins_hash_pair(p->fun, p->newval, h);
}

static uint32_t hash_distinct_term(distinct_term_hobj_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0x783426);
}

static uint32_t hash_forall_term(forall_term_hobj_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray_var(p->nvars, p->var, 0x9172ea9f);
  return jenkins_hash_pair(p->body, 0, h);
}

static uint32_t hash_arith_buffer_term(arith_buffer_hobj_t *p) {
  uint32_t h;
  h = arith_buffer_hash(p->b);
  return jenkins_hash_pair(p->tag, 0, h);
}

static uint32_t hash_monarray_term(monarray_hobj_t *p) {
  uint32_t h;
  h = hash_monarray(p->mono);
  return jenkins_hash_pair(p->tag, 0, h);
}

static uint32_t hash_arith_bineq_atom(arith_bineq_hobj_t *p) {
  return jenkins_hash_pair(p->left, p->right, 0x761bedaf);
}

static uint32_t hash_bvarith_term(bvarith_hobj_t *p) {
  return bvarith_buffer_hash(p->b);
}

static uint32_t hash_bvlogic_term(bvlogic_hobj_t *p) {
  return bvlogic_buffer_hash(p->b);
}

static uint32_t hash_bvconst_term(bvconst_hobj_t *p) {
  int32_t k;
  k = (p->nbits + 31) >> 5; // number of 32-bit words 
  return jenkins_hash_intarray_var(k, (int32_t *) p->bits, 0x71837ae4);
}

static uint32_t hash_bvatom(bvatom_hobj_t *p) {
  return jenkins_hash_triple(p->left, p->right, p->tag, 0x7aaf3277);
}

static uint32_t hash_bvapply_term(bvapply_term_hobj_t *p) {
  return jenkins_hash_triple(p->op, p->arg0, p->arg1, 0x8317ed8);
}



/*
 * Equality tests
 */
static bool equal_constant_term(constant_term_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  return table->kind[i] == CONSTANT_TERM && table->type[i] == p->tau &&
    table->desc[i].integer == p->idx;
}

static bool equal_variable(variable_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  return table->kind[i] == VARIABLE && table->type[i] == p->tau &&
    table->desc[i].integer == p->idx;
}

static bool equal_ite_term(ite_term_hobj_t *p, term_t i) {
  term_table_t *table;
  ite_term_t *d;

  table = p->tbl;
  if (table->kind[i] != ITE_TERM) return false;

  d = (ite_term_t *) table->desc[i].ptr;
  return d->cond == p->cond && d->then_arg == p->then_arg && d->else_arg == p->else_arg;
}

static bool equal_eq_term(eq_term_hobj_t *p, term_t i) {
  term_table_t *table;
  eq_term_t *d;

  table = p->tbl;
  if (table->kind[i] != EQ_TERM) return false;

  d = (eq_term_t *) table->desc[i].ptr;
  return d->left == p->left && d->right == p->right;
}

static bool equal_app_term(app_term_hobj_t *p, term_t i) {
  term_table_t *table;
  app_term_t *d;
  uint32_t j;

  table = p->tbl;
  if (table->kind[i] != APP_TERM) return false;

  d = (app_term_t *) table->desc[i].ptr;
  if (d->fun != p->fun) return false;

  assert(d->nargs == p->nargs);
  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_or_term(or_term_hobj_t *p, term_t i) {
  term_table_t *table;
  or_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != OR_TERM) return false;

  d = (or_term_t *) table->desc[i].ptr;
  if (d->nargs != p->nargs) return false;

  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_not_term(not_term_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;

  return table->kind[i] == NOT_TERM && table->desc[i].integer == p->arg;
}

static bool equal_tuple_term(tuple_term_hobj_t *p, term_t i) {
  term_table_t *table;
  tuple_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != TUPLE_TERM) return false;

  d = (tuple_term_t *) table->desc[i].ptr;
  if (d->nargs != p->nargs) return false;

  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_select_term(select_term_hobj_t *p, term_t i) {
  term_table_t *table;
  select_term_t *d;

  table = p->tbl;
  if (table->kind[i] != SELECT_TERM) return false;

  d = (select_term_t *) table->desc[i].ptr;
  return p->idx == d->idx && p->arg == d->arg;
}

static bool equal_update_term(update_term_hobj_t *p, term_t i) {
  term_table_t *table;
  update_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != UPDATE_TERM) return false;

  d = (update_term_t *) table->desc[i].ptr;
  if (d->fun != p->fun || d->newval != p->newval) return false;

  assert(d->nargs == p->nargs);
  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_distinct_term(distinct_term_hobj_t *p, term_t i) {
  term_table_t *table;
  distinct_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != DISTINCT_TERM) return false;

  d = (distinct_term_t *) table->desc[i].ptr;
  if (d->nargs != p->nargs) return false;

  for (j=0; j<p->nargs; j++) {
    if (d->arg[j] != p->arg[j]) return false;
  }

  return true;
}

static bool equal_forall_term(forall_term_hobj_t *p, term_t i) {
  term_table_t *table;
  forall_term_t *d;
  int32_t j;

  table = p->tbl;
  if (table->kind[i] != FORALL_TERM) return false;

  d = (forall_term_t *) table->desc[i].ptr;
  if (d->nvars != p->nvars || d->body != p->body) return false;

  for (j=0; j<p->nvars; j++) {
    if (d->var[j] != p->var[j]) return false;
  }

  return true;
}

static bool equal_arith_buffer_term(arith_buffer_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  if (table->kind[i] != p->tag) return false;

  return arith_buffer_equal_polynomial(p->b, (polynomial_t *) table->desc[i].ptr);
}

static bool equal_monarray_term(monarray_hobj_t *p, term_t i) {
  term_table_t *table;
  polynomial_t *d;

  table = p->tbl;
  if (table->kind[i] != p->tag) return false;
  d = (polynomial_t *) table->desc[i].ptr;
  return p->nterms == d->nterms && equal_monarray(p->mono, d->mono);
}

static bool equal_arith_bineq_atom(arith_bineq_hobj_t *p, term_t i) {
  term_table_t *table;
  arith_bineq_t *d;

  table = p->tbl;
  if (table->kind[i] != ARITH_BINEQ_ATOM) return false;

  d = (arith_bineq_t *) table->desc[i].ptr;
  return d->left == p->left && d->right == p->right;
}

static bool equal_bvarith_term(bvarith_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  if (table->kind[i] != BV_ARITH_TERM) return false;

  return bvarith_buffer_equal_expr(p->b, (bvarith_expr_t *) table->desc[i].ptr);
}

static bool equal_bvlogic_term(bvlogic_hobj_t *p, term_t i) {
  term_table_t *table;

  table = p->tbl;
  if (table->kind[i] != BV_LOGIC_TERM) return false;
  return bvlogic_buffer_equal_expr(p->b, (bvlogic_expr_t *) table->desc[i].ptr);
}

static bool equal_bvconst_term(bvconst_hobj_t *p, term_t i) {
  term_table_t *table;
  bvconst_term_t *d;  

  table = p->tbl;
  if (table->kind[i] != BV_CONST_TERM) return false;

  d = (bvconst_term_t *) table->desc[i].ptr;
  return d->nbits == p->nbits && bvconst_eq(d->bits, p->bits, (p->nbits + 31) >> 5);
}

static bool equal_bvatom(bvatom_hobj_t *p, term_t i) {
  term_table_t *table;
  bv_atom_t *d;

  table = p->tbl;
  if (table->kind[i] != p->tag) return false;

  d = (bv_atom_t *) table->desc[i].ptr;
  return d->left == p->left && d->right == p->right;
}

static bool equal_bvapply_term(bvapply_term_hobj_t *p, term_t i) {
  term_table_t *table;
  bvapply_term_t *d;

  table = p->tbl;
  if (table->kind[i] != BV_APPLY_TERM) return false;

  d = (bvapply_term_t *) table->desc[i].ptr;
  return d->arg0 == p->arg0 && d->arg1 == p->arg1 && d->op == p->op;
}


/*
 * Build functions
 */
static term_t build_constant_term(constant_term_hobj_t *p) {
  return new_constant_term(p->tbl, p->tau, p->idx);
}

static term_t build_variable(variable_hobj_t *p) {
  return new_variable(p->tbl, p->tau, p->idx);
}

static term_t build_ite_term(ite_term_hobj_t *p) {
  return new_ite_term(p->tbl, p->cond, p->then_arg, p->else_arg, p->type);
}

static term_t build_eq_term(eq_term_hobj_t *p) {
  return new_eq_term(p->tbl, p->left, p->right);
}

static term_t build_app_term(app_term_hobj_t *p) {
  return new_app_term(p->tbl, p->fun, p->nargs, p->arg);
}

static term_t build_or_term(or_term_hobj_t *p) {
  return new_or_term(p->tbl, p->nargs, p->arg);
}

static term_t build_not_term(not_term_hobj_t *p) {
  return new_not_term(p->tbl, p->arg);
}

static term_t build_tuple_term(tuple_term_hobj_t *p) {
  return new_tuple_term(p->tbl, p->nargs, p->arg);
}

static term_t build_select_term(select_term_hobj_t *p) {
  return new_select_term(p->tbl, p->idx, p->arg);
}

static term_t build_update_term(update_term_hobj_t *p) {
  return new_update_term(p->tbl, p->fun, p->nargs, p->arg, p->newval);
}

static term_t build_distinct_term(distinct_term_hobj_t *p) {
  return new_distinct_term(p->tbl, p->nargs, p->arg);
}

static term_t build_forall_term(forall_term_hobj_t *p) {
  return new_forall_term(p->tbl, p->nvars, p->var, p->body);
}

static term_t build_arith_buffer_term(arith_buffer_hobj_t *p) {
  polynomial_t *poly;
  poly = arith_buffer_getpoly(p->b);
  if (p->tag == ARITH_TERM) {
    return new_arith_term(p->tbl, poly);
  } else {
    return new_arith_atom(p->tbl, p->tag, poly);
  }
}

static term_t build_monarray_term(monarray_hobj_t *p) {
  polynomial_t *poly;
  poly = monarray_getpoly(p->mono, p->nterms);
  if (p->tag == ARITH_TERM) {
    return new_arith_term(p->tbl, poly);
  } else {
    return new_arith_atom(p->tbl, p->tag, poly);
  }
}

static term_t build_arith_bineq_atom(arith_bineq_hobj_t *p) {
  return new_arith_bineq_atom(p->tbl, p->left, p->right);
}

static term_t build_bvarith_term(bvarith_hobj_t *p) {
  return new_bvarith_term(p->tbl, bvarith_buffer_get_expr(p->b));
}

static term_t build_bvlogic_term(bvlogic_hobj_t *p) {
  return new_bvlogic_term(p->tbl, bvlogic_buffer_get_expr(p->b));
}

static term_t build_bvconst_term(bvconst_hobj_t *p) {
  return new_bvconst_term(p->tbl, p->nbits, p->bits);
}

static term_t build_bvatom(bvatom_hobj_t *p) {
  return new_bvatom(p->tbl, p->tag, p->left, p->right);
}

static term_t build_bvapply_term(bvapply_term_hobj_t *p) {
  return new_bvapply_term(p->tbl, p->op, p->arg0, p->arg1);
}


/*
 * Global hash objects
 */
static constant_term_hobj_t constant_hobj = {
  { (hobj_hash_t) hash_constant_term, (hobj_eq_t) equal_constant_term, 
    (hobj_build_t) build_constant_term },
  NULL,
  0, 0,
};

static variable_hobj_t variable_hobj = {
  { (hobj_hash_t) hash_variable, (hobj_eq_t) equal_variable, 
    (hobj_build_t) build_variable },
  NULL,
  0, 0,
};

static ite_term_hobj_t ite_hobj = {
  { (hobj_hash_t) hash_ite_term, (hobj_eq_t) equal_ite_term, 
    (hobj_build_t) build_ite_term },
  NULL,
  0, 0, 0, 0,
};

static eq_term_hobj_t eq_hobj = {
  { (hobj_hash_t) hash_eq_term, (hobj_eq_t) equal_eq_term,
    (hobj_build_t) build_eq_term },
  NULL,
  0, 0,
};

static app_term_hobj_t app_hobj = {
  { (hobj_hash_t) hash_app_term, (hobj_eq_t) equal_app_term,
    (hobj_build_t) build_app_term },
  NULL,
  0, 0, NULL,
};

static or_term_hobj_t or_hobj = {
  { (hobj_hash_t) hash_or_term, (hobj_eq_t) equal_or_term,
    (hobj_build_t) build_or_term },
  NULL,
  0, NULL,
};

static not_term_hobj_t not_hobj = {
  { (hobj_hash_t) hash_not_term, (hobj_eq_t) equal_not_term,
    (hobj_build_t) build_not_term },
  NULL,
  0,
};

static tuple_term_hobj_t tuple_hobj = {
  { (hobj_hash_t) hash_tuple_term, (hobj_eq_t) equal_tuple_term,
    (hobj_build_t) build_tuple_term },
  NULL,
  0, NULL,
};

static select_term_hobj_t select_hobj = {
  { (hobj_hash_t) hash_select_term, (hobj_eq_t) equal_select_term,
    (hobj_build_t) build_select_term },
  NULL,
  0, 0,
};

static update_term_hobj_t update_hobj = {
  { (hobj_hash_t) hash_update_term, (hobj_eq_t) equal_update_term,
    (hobj_build_t) build_update_term },
  NULL,
  0, 0, 0, NULL,
};

static distinct_term_hobj_t distinct_hobj = {
  { (hobj_hash_t) hash_distinct_term, (hobj_eq_t) equal_distinct_term,
    (hobj_build_t) build_distinct_term },
  NULL,
  0, NULL,
};

static forall_term_hobj_t forall_hobj = {
  { (hobj_hash_t) hash_forall_term, (hobj_eq_t) equal_forall_term,
    (hobj_build_t) build_forall_term },
  NULL,
  0, 0, NULL,
};

static arith_buffer_hobj_t arith_buffer_hobj = {
  { (hobj_hash_t) hash_arith_buffer_term, (hobj_eq_t) equal_arith_buffer_term,
    (hobj_build_t) build_arith_buffer_term },
  NULL,
  NULL, UNUSED_TERM,
};

static monarray_hobj_t monarray_hobj = {
  { (hobj_hash_t) hash_monarray_term, (hobj_eq_t) equal_monarray_term,
    (hobj_build_t) build_monarray_term },
  NULL,
  NULL, 0, UNUSED_TERM,
};

static arith_bineq_hobj_t arith_bineq_hobj = {
  { (hobj_hash_t) hash_arith_bineq_atom, (hobj_eq_t) equal_arith_bineq_atom,
    (hobj_build_t) build_arith_bineq_atom },
  NULL,
  0, 0,
};

static bvarith_hobj_t bvarith_hobj = {
  { (hobj_hash_t) hash_bvarith_term, (hobj_eq_t) equal_bvarith_term,
    (hobj_build_t) build_bvarith_term },
  NULL,
  NULL,
};

static bvlogic_hobj_t bvlogic_hobj = {
  { (hobj_hash_t) hash_bvlogic_term, (hobj_eq_t) equal_bvlogic_term,
    (hobj_build_t) build_bvlogic_term },
  NULL,
  NULL,
};

static bvconst_hobj_t bvconst_hobj = {
  { (hobj_hash_t) hash_bvconst_term, (hobj_eq_t) equal_bvconst_term,
    (hobj_build_t) build_bvconst_term },
  NULL,
  0, NULL,
};

static bvatom_hobj_t bvatom_hobj = {
  { (hobj_hash_t) hash_bvatom, (hobj_eq_t) equal_bvatom,
    (hobj_build_t) build_bvatom },
  NULL,
  0, 0, UNUSED_TERM,
};

static bvapply_term_hobj_t bvapply_term_hobj = {
  { (hobj_hash_t) hash_bvapply_term, (hobj_eq_t) equal_bvapply_term,
    (hobj_build_t) build_bvapply_term },
  NULL,
  0, 0, UNUSED_TERM,
};



/****************
 *  MODULE API  *
 ***************/


/*
 * Add the boolean constant
 */
static void add_primitive_term(term_table_t *table) {
  int32_t i;

  i = allocate_term_id(table);
  assert(i == bool_const);

  table->kind[i] = CONSTANT_TERM;
  table->type[i] = bool_type(table->types);
  table->desc[i].integer = 0;
}


/*
 * Initialize table with initial size = n.
 * Create the built-in constants.
 */
void init_term_table(term_table_t *table, uint32_t n, type_table_t *ttbl, 
		     arithvar_manager_t *arith_m, bv_var_manager_t *bv_m) {
  term_table_init(table, n, ttbl, arith_m, bv_m);
  add_primitive_terms(table);
}

/*
 * Delete table
 */
void delete_term_table(term_table_t *table) {
  uint32_t i;

  // delete all descriptors
  for (i=0; i<table->nelems; i++) {
    switch (table->kind[i]) {
    case UNUSED_TERM:
    case CONSTANT_TERM:
    case UNINTERPRETED_TERM:
    case VARIABLE:
    case NOT_TERM:
      break;

    case ITE_TERM:
    case EQ_TERM:
    case APP_TERM:
    case OR_TERM:
    case TUPLE_TERM:
    case SELECT_TERM:
    case UPDATE_TERM:
    case DISTINCT_TERM:
    case FORALL_TERM:
      safe_free(table->desc[i].ptr);
      break;

    case ARITH_TERM:
    case ARITH_EQ_ATOM:
    case ARITH_GE_ATOM:
      free_polynomial(table->desc[i].ptr);
      break;

    case ARITH_BINEQ_ATOM:
    case BV_LOGIC_TERM:
    case BV_ARITH_TERM:
    case BV_CONST_TERM:
    case BV_EQ_ATOM:
    case BV_GE_ATOM:
    case BV_SGE_ATOM:
    case BV_APPLY_TERM:
      safe_free(table->desc[i].ptr);
      break;
    }
  }

  safe_free(table->kind);
  safe_free(table->type);
  safe_free(table->desc);
  delete_bitvector(table->mark);
  delete_int_htbl(&table->htbl);
  delete_stbl(&table->stbl);
  safe_free(table->buffer);

  table->kind = NULL;
  table->type = NULL;
  table->desc = NULL;
  table->mark = NULL;
}



/***********************
 *  TERM CONSTRUCTION  *
 **********************/

/*
 * Construct constant term of given type and index.
 */
term_t constant_term(term_table_t *table, type_t tau, int32_t index) {
  constant_hobj.tbl = table;
  constant_hobj.tau = tau;
  constant_hobj.idx = index;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &constant_hobj);
}

/*
 * Construct variable of type tau and given index
 */
term_t variable(term_table_t *table, type_t tau, int32_t index) {
  variable_hobj.tbl = table;
  variable_hobj.tau = tau;
  variable_hobj.idx = index;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &variable_hobj);
}

/*
 * Composite terms
 */
term_t ite_term(term_table_t *table, term_t cond, term_t then_term, term_t else_term, type_t tau) {
  assert(tau == super_type(table->types, term_type(table, then_term), 
			   term_type(table, else_term)));

  ite_hobj.tbl = table;
  ite_hobj.cond = cond;
  ite_hobj.then_arg = then_term;
  ite_hobj.else_arg = else_term;
  ite_hobj.type = tau;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &ite_hobj);
}

term_t eq_term(term_table_t *table, term_t left, term_t right) {
  eq_hobj.tbl = table;
  eq_hobj.left = left;
  eq_hobj.right = right;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &eq_hobj);
}

term_t app_term(term_table_t *table, term_t fun, int32_t n, term_t arg[]) {
  app_hobj.tbl = table;
  app_hobj.nargs = n;
  app_hobj.fun = fun;
  app_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &app_hobj);
}

term_t or_term(term_table_t *table, int32_t n, term_t arg[]) {
  or_hobj.tbl = table;
  or_hobj.nargs = n;
  or_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &or_hobj);
}

term_t not_term(term_table_t *table, term_t arg) {
  not_hobj.tbl = table;
  not_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &not_hobj);
}

term_t tuple_term(term_table_t *table, int32_t n, term_t arg[]) {
  tuple_hobj.tbl = table;
  tuple_hobj.nargs = n;
  tuple_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &tuple_hobj);
}

term_t select_term(term_table_t *table, int32_t index, term_t tuple) {
  select_hobj.tbl = table;
  select_hobj.idx = index;
  select_hobj.arg = tuple;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &select_hobj);  
}

term_t update_term(term_table_t *table, term_t fun, int32_t n, term_t arg[], term_t new_v) {
  update_hobj.tbl = table;
  update_hobj.fun = fun;
  update_hobj.newval = new_v;
  update_hobj.nargs = n;
  update_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &update_hobj);
}

term_t distinct_term(term_table_t *table, int32_t n, term_t arg[]) {
  distinct_hobj.tbl = table;
  distinct_hobj.nargs = n;
  distinct_hobj.arg = arg;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &distinct_hobj);
}

term_t forall_term(term_table_t *table, int32_t n, term_t var[], term_t body) {
  forall_hobj.tbl = table;
  forall_hobj.body = body;
  forall_hobj.nvars = n;
  forall_hobj.var = var;

  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &forall_hobj);
}


/*
 * Arithmetic terms and atoms
 */
term_t arith_object_from_buffer(term_table_t *table, term_kind_t tag, arith_buffer_t *b) {
  arith_buffer_hobj.tbl = table;
  arith_buffer_hobj.b = b;
  arith_buffer_hobj.tag = tag;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &arith_buffer_hobj);
}

term_t arith_object_from_monarray(term_table_t *table, term_kind_t tag, monomial_t *p, int32_t n) {
  monarray_hobj.tbl = table;
  monarray_hobj.mono = p;
  monarray_hobj.nterms = n;
  monarray_hobj.tag = tag;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &monarray_hobj);
}

term_t arith_bineq_atom(term_table_t *table, term_t l, term_t r) {
  arith_bineq_hobj.tbl = table;
  arith_bineq_hobj.left = l;
  arith_bineq_hobj.right = r;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &arith_bineq_hobj);
}


/*
 * Bitvector terms and atoms
 */
term_t bvarith_term(term_table_t *table, bvarith_buffer_t *b) {
  bvarith_hobj.tbl = table;
  bvarith_hobj.b = b;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvarith_hobj);
}

term_t bvlogic_term(term_table_t *table, bvlogic_buffer_t *b) {
  bvlogic_hobj.tbl = table;
  bvlogic_hobj.b = b;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvlogic_hobj);
}

term_t bvconst_term(term_table_t *table, int32_t n, uint32_t *b) {
  bvconst_hobj.tbl = table;
  bvconst_hobj.nbits = n;
  bvconst_hobj.bits = b;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvconst_hobj);
}

term_t bitvector_atom(term_table_t *table, term_kind_t tag, term_t l, term_t r) {
  bvatom_hobj.tbl = table;
  bvatom_hobj.tag = tag;
  bvatom_hobj.left = l;
  bvatom_hobj.right = r;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvatom_hobj);
}

term_t bvapply_term(term_table_t *table, uint32_t op, term_t l, term_t r) {
  bvapply_term_hobj.tbl = table;
  bvapply_term_hobj.arg0 = l;
  bvapply_term_hobj.arg1 = r;
  bvapply_term_hobj.op = op;
  return int_htbl_get_obj(&table->htbl, (int_hobj_t *) &bvapply_term_hobj);
}


/*
 * Hash code of terms (same as hash_constant_term to hash_bvatom)
 */
static uint32_t hash_constant(type_t tau, int32_t idx) {
  return jenkins_hash_pair(tau, idx, 0x19ef312c);
}

static uint32_t hash_var(type_t tau, int32_t idx) {
  return jenkins_hash_pair(tau, idx, 0x83891aef);
}

static uint32_t hash_ite(ite_term_t *p) {
  return jenkins_hash_triple(p->cond, p->then_arg, p->else_arg, 0x9f34197a);
}

static uint32_t hash_eq(eq_term_t *p) {
  return jenkins_hash_pair(p->left, p->right, 0x78d2bae1);
}

static uint32_t hash_app(app_term_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray(p->nargs, p->arg);
  return jenkins_hash_pair(p->fun, 0, h);
}

static uint32_t hash_or(or_term_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0xf82bf286);
}

static uint32_t hash_not(term_t arg) {
  return jenkins_hash_pair(arg, 0, 0x183b42e6);
}

static uint32_t hash_tuple(tuple_term_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0xae7bd466);
}

static uint32_t hash_select(select_term_t *p) {
  return jenkins_hash_pair(p->arg, p->idx, 0x4137bee9);
}

static uint32_t hash_update(update_term_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray_var(p->nargs, p->arg, 0x378a121a);
  return jenkins_hash_pair(p->fun, p->newval, h);
}

static uint32_t hash_distinct(distinct_term_t *p) {
  return jenkins_hash_intarray_var(p->nargs, p->arg, 0x783426);
}

static uint32_t hash_forall(forall_term_t *p) {
  uint32_t h;
  h = jenkins_hash_intarray_var(p->nvars, p->var, 0x9172ea9f);
  return jenkins_hash_pair(p->body, 0, h);
}

static uint32_t hash_arith(polynomial_t *p, term_kind_t tag) {
  uint32_t h;
  h = hash_monarray(p->mono);
  return jenkins_hash_pair(tag, 0, h);
}

static uint32_t hash_arith_bineq(arith_bineq_t *p) {
  return jenkins_hash_pair(p->left, p->right, 0x761bedaf);
}

static uint32_t hash_bvarith(bvarith_expr_t *p) {
  return bvarith_expr_hash(p);
}

static uint32_t hash_bvlogic(bvlogic_expr_t *p) {
  return bvlogic_expr_hash(p);
}

static uint32_t hash_bvconst(bvconst_term_t *p) {
  int32_t k;
  k = (p->nbits + 31) >> 5; // number of 32-bit words 
  return jenkins_hash_intarray_var(k, (int32_t *) p->bits, 0x71837ae4);
}

static uint32_t hash_bvatm(bv_atom_t *p, term_kind_t tag) {
  return jenkins_hash_triple(p->left, p->right, tag, 0x7aaf3277);
}

static uint32_t hash_bvterm(bvapply_term_t *p) {
  return jenkins_hash_triple(p->op, p->arg0, p->arg1, 0x8317ed8);
}

/*
 * Remove a term t from the hash-consing table
 */
static void erase_hcons_record(term_table_t *table, term_t i) {
  uint32_t k; // hash code

  switch (table->kind[i]) {
  case CONSTANT_TERM:
    k = hash_constant(table->type[i], table->desc[i].integer);
    break;

  case VARIABLE:
    k = hash_var(table->type[i], table->desc[i].integer);
    break;
    
  case NOT_TERM:
    k = hash_not(table->desc[i].integer);
    break;

  case ITE_TERM:
    k = hash_ite(table->desc[i].ptr);
    break;

  case EQ_TERM:
    k = hash_eq(table->desc[i].ptr);
    break;

  case APP_TERM:
    k = hash_app(table->desc[i].ptr);
    break;

  case OR_TERM:
    k = hash_or(table->desc[i].ptr);
    break;

  case TUPLE_TERM:
    k = hash_tuple(table->desc[i].ptr);
    break;

  case SELECT_TERM:
    k = hash_select(table->desc[i].ptr);
    break;

  case UPDATE_TERM:
    k = hash_update(table->desc[i].ptr);
    break;

  case DISTINCT_TERM:
    k = hash_distinct(table->desc[i].ptr);
    break;

  case FORALL_TERM:
    k = hash_forall(table->desc[i].ptr);
    break;

  case ARITH_TERM:
    k = hash_arith(table->desc[i].ptr, ARITH_TERM);
    break;

  case ARITH_EQ_ATOM:
    k = hash_arith(table->desc[i].ptr, ARITH_EQ_ATOM);
    break;

  case ARITH_GE_ATOM:
    k = hash_arith(table->desc[i].ptr, ARITH_GE_ATOM);
    break;

  case ARITH_BINEQ_ATOM:
    k = hash_arith_bineq(table->desc[i].ptr);
    break;

  case BV_LOGIC_TERM:
    k = hash_bvlogic(table->desc[i].ptr);
    break;

  case BV_ARITH_TERM:
    k = hash_bvarith(table->desc[i].ptr);
    break;

  case BV_CONST_TERM:
    k = hash_bvconst(table->desc[i].ptr);
    break;

  case BV_EQ_ATOM:
    k = hash_bvatm(table->desc[i].ptr, BV_EQ_ATOM);
    break;

  case BV_GE_ATOM:
    k = hash_bvatm(table->desc[i].ptr, BV_GE_ATOM);
    break;

  case BV_SGE_ATOM:
    k = hash_bvatm(table->desc[i].ptr, BV_SGE_ATOM);
    break;

  case BV_APPLY_TERM:
    k = hash_bvterm(table->desc[i].ptr);
    break;

  default:
    return;
  }

  int_htbl_erase_record(&table->htbl, k, i);
}


/****************
 *  TERM NAMES  *
 ***************/

/*
 * Assign name to term t
 * - name must be a string with refcounter 
 */
void set_term_name(term_table_t *table, term_t t, char *name) {
  if (table->name[t] == NULL) {
    table->name[t] = name;
    string_incref(name);
  }
  stbl_add(&table->stbl, name, t);
  string_incref(name);
}


/*
 * Get term of the given name
 */
term_t get_term_by_name(term_table_t *table, char *name) {
  term_t t;

  t = stbl_find(&table->stbl, name);
  return (t >= 0) ? t : NULL_TERM;
}


/*
 * Remove term name
 */
void remove_term_name(term_table_t *table, char *name) {
  stbl_remove(&table->stbl, name);
}


/***********************
 * GARBAGE COLLECTION  *
 **********************/

/*
 * Support for type-table garbage collection
 * - mark all types in the term table to prevent them from
 *   being removed from the type table
 * - must be called only via the gc_notifier attached to the type
 *   table table->types.
 */
void mark_term_types(term_table_t *table) {
  types_t *tbl;
  term_t i;
  int32_t n;

  tbl = table->types;
  n = table->nelems;
  for (i=0; i<n; i++) {
    if (table->kind[i] != UNUSED_TERM) {
      gc_mark_type(tbl, table->type[i]);
    }
  }
}


/*
 * Term garbage collection: terms with root_flag set are not deleted.
 */
void set_root_term_flag(term_table_t *table, term_t i) {
  set_bit(table->mark, i);
}

void clr_root_term_flag(term_table_t *table, term_t i) {
  clr_bit(table->mark, i);
}



/*
 * Marking for garbage collection of terms
 * - mark_queue = bitvector. One bit per term
 *   if mark_queue[t] = 0 then t will be deleted otherwise it
 *   will be kept.
 * - q = integer queue for processing subterms (breadth-first)
 */

// mark t if it's not already marked and add it to the queue
static void gc_mark_push_term(int_queue_t *q, byte_t *mark, term_t t) {
  if (! tst_bit(mark, t)) {
    set_bit(mark, t);
    int_queue_push(q, t);
  }
}

// same thing for terms a[0] ... a[n-1]
static void gc_mark_push_array(int_queue_t *q, byte_t *mark, term_t *a, int32_t n) {
  int32_t i;

  for (i=0; i<n; i++) {
    gc_mark_push_term(q, mark, a[i]);
  }
}

// mark components of a term
static inline void gc_mark_ite(int_queue_t *q, byte_t *mark, ite_term_t *ite) {
  gc_mark_push_term(q, mark, ite->cond);
  gc_mark_push_term(q, mark, ite->then_arg);
  gc_mark_push_term(q, mark, ite->else_arg);
}

static inline void gc_mark_eq(int_queue_t *q, byte_t *mark, eq_term_t *eq) {
  gc_mark_push_term(q, mark, eq->left);
  gc_mark_push_term(q, mark, eq->right);  
}

static inline void gc_mark_app(int_queue_t *q, byte_t *mark, app_term_t *app) {
  gc_mark_push_term(q, mark, app->fun);
  gc_mark_push_array(q, mark, app->arg, app->nargs);
}

static inline void gc_mark_or(int_queue_t *q, byte_t *mark, or_term_t *or) {
  gc_mark_push_array(q, mark, or->arg, or->nargs);
}

static inline void gc_mark_tuple(int_queue_t *q, byte_t *mark, tuple_term_t *tuple) {
  gc_mark_push_array(q, mark, tuple->arg, tuple->nargs);
}

static inline void gc_mark_select(int_queue_t *q, byte_t *mark, select_term_t *select) {
  gc_mark_push_term(q, mark, select->arg);
}

static inline void gc_mark_update(int_queue_t *q, byte_t *mark, update_term_t *update) {
  gc_mark_push_term(q, mark, update->fun);
  gc_mark_push_term(q, mark, update->newval);
  gc_mark_push_array(q, mark, update->arg, update->nargs);
}

static inline void gc_mark_distinct(int_queue_t *q, byte_t *mark, distinct_term_t *distinct) {
  gc_mark_push_array(q, mark, distinct->arg, distinct->nargs);
}

static inline void gc_mark_forall(int_queue_t *q, byte_t *mark, forall_term_t *forall) {
  gc_mark_push_array(q, mark, forall->var, forall->nvars);
  gc_mark_push_term(q, mark, forall->body);
}

static inline void gc_mark_bvatom(int_queue_t *q, byte_t *mark, bv_atom_t *atom) {
  gc_mark_push_term(q, mark, atom->left);
  gc_mark_push_term(q, mark, atom->right);  
}

static inline void gc_mark_bvterm(int_queue_t *q, byte_t *mark, bvapply_term_t *bvt) {
  gc_mark_push_term(q, mark, bvt->arg0);
  gc_mark_push_term(q, mark, bvt->arg1);  
}


/*
 * Mark terms reachable from a polynomial
 * - every variable x in the monomial array that has degree 1 represents a term
 *   in the term table. That term is marked.
 */
static void gc_mark_polynomial(int_queue_t *q, byte_t *mark, polynomial_manager_t *m, polynomial_t *p) {
  int32_t i, n;
  arith_var_t x;

  n = p->nterms;
  for (i=0; i<n; i++) {
    x = p->mono[i].var;
    if (polymanager_var_is_primitive(m, x)) {
      gc_mark_push_term(q, mark, polymanager_var_index(m, x));
    }
  }
}

/*
 * Subterms of an arithmetic equality
 */
static inline void gc_mark_arith_bineq(int_queue_t *q, byte_t *mark, arith_bineq_t *eq) {
  gc_mark_push_term(q, mark, eq->left);
  gc_mark_push_term(q, mark, eq->right);  
}


/*
 * Mark terms reachable from a bitvector arithmetic expression
 * - every variable x in the monomial array that has degree 1 represents a term
 *   in the term table. That term is marked.
 */
static void gc_mark_bvarith_expr(int_queue_t *q, byte_t *mark, polynomial_manager_t *m, bvarith_expr_t *e) {
  int32_t i, n;
  bv_var_t x;

  n = e->nterms;
  for (i=0; i<n; i++) {
    x = e->mono[i].var;
    if (polymanager_var_is_primitive(m, x)) {
      gc_mark_push_term(q, mark, polymanager_var_index(m, x));
    }
  }
}


/*
 * Mark terms reachable from a bdd array:
 * - bm: auxiliary marker to avoid visiting the same node twice
 * - the term marking is done by the callback function attached to 
 *   bm->marker (i.e., mark_term_from_bit_expr)
 */
static void gc_mark_bvlogic_expr(term_bit_marker_t *bm, bvlogic_expr_t *bv) {
  uint32_t i, n;

  n = bv->nbits;
  for (i=0; i<n; i++) {
    bit_marker_visit(&bm->marker, node_of_bit(bv->bit[i]));
  }
}


/*
 * Mark term t and all its subterms
 * - must be called only after table->gc_mark and table->gc_mark_queue
 * have been initialized (i.e., within a gc_notifier).
 */
void gc_mark_term(term_table_t *table, term_t t) {
  int_queue_t *q;
  byte_t *mark;

  assert(table->gc_mark != NULL);
  assert(table->gc_mark_queue != NULL);

  mark = table->gc_mark;
  if (! tst_bit(mark, t)) {
    set_bit(mark, t);
    q = table->gc_mark_queue;
    for (;;) {
      switch(table->kind[t]) {
      case UNUSED_TERM:
      case CONSTANT_TERM:    
      case UNINTERPRETED_TERM:
      case VARIABLE:
	break;
      case NOT_TERM:
	gc_mark_push_term(q, mark, table->desc[t].integer);
	break;
      case ITE_TERM:
	gc_mark_ite(q, mark, table->desc[t].ptr);
	break;
      case EQ_TERM:
	gc_mark_eq(q, mark, table->desc[t].ptr);
	break;
      case APP_TERM:
	gc_mark_app(q, mark, table->desc[t].ptr);
	break;
      case OR_TERM:
	gc_mark_or(q, mark, table->desc[t].ptr);
	break;
      case TUPLE_TERM:
	gc_mark_tuple(q, mark, table->desc[t].ptr);
	break;
      case SELECT_TERM:
	gc_mark_select(q, mark, table->desc[t].ptr);
	break;
      case UPDATE_TERM:
	gc_mark_update(q, mark, table->desc[t].ptr);
	break;
      case DISTINCT_TERM:
	gc_mark_distinct(q, mark, table->desc[t].ptr);
	break;
      case FORALL_TERM:
	gc_mark_forall(q, mark, table->desc[t].ptr);
	break;

      case ARITH_TERM:
      case ARITH_EQ_ATOM:
      case ARITH_GE_ATOM:
	gc_mark_polynomial(q, mark, &table->arith_manager->pm, table->desc[t].ptr);
	break;
      case ARITH_BINEQ_ATOM:
	gc_mark_arith_bineq(q, mark, table->desc[t].ptr);
	break;
      case BV_LOGIC_TERM:
	gc_mark_bvlogic_expr(table->gc_bit_marker, table->desc[t].ptr);
	break;
      case BV_ARITH_TERM:
	gc_mark_bvarith_expr(q, mark, &table->bv_manager->pm, table->desc[t].ptr);
	break;

      case BV_CONST_TERM:
	break;
      case BV_EQ_ATOM:
      case BV_GE_ATOM:
      case BV_SGE_ATOM:
	gc_mark_bvatom(q, mark, table->desc[t].ptr);
	break;
      case BV_APPLY_TERM:
	gc_mark_bvterm(q, mark, table->desc[t].ptr);
	break;
      }

      if (int_queue_is_empty(q)) break;
      t = int_queue_pop(q);
    }
  }
}





/*
 * Marker function: callback in table->gc_bit_marker.
 *
 * Mark term that may be reachable from the bit-variable of node:
 * - that variable may be attached to a bit-vector variable v
 * - v may be attached to a term t (if v is a primitive variable).
 * Object o store the following data:
 * - nodes: node tables for all bvlogic_expr of the table
 * - pm: bitvector variable manager for all bvlogic and bvarith expressions
 * - mark, q: term marking and queue 
 * 
 * - node is the id of a node reachable from a bvlogic_expr term
 */
static void mark_term_from_bit_expr(void *o, node_t node) {
  term_bit_marker_t *p;
  int32_t v;

  p = (term_bit_marker_t *) o;
  if (is_variable_node(p->nodes, node)) {
    v = bv_var_of_node(p->nodes, node);
    if (v >= 0 && polymanager_var_is_primitive(p->pm, v)) {
      gc_mark_push_term(p->q, p->mark, polymanager_var_index(p->pm, v));
    }
  }
}



/*
 * Mark all terms with root_flag set and all terms accessible from the symbol table. 
 */
static void mark_live_terms(term_table_t *table) {
  stbl_t *sym_table;
  stbl_bank_t *b;
  stbl_rec_t *r;
  term_t i;
  uint32_t k;

  // mark terms accessible from the symbol table
  sym_table = &table->stbl;
  k = sym_table->free_idx;
  for (b = sym_table->bnk; b != NULL; b = b->next) {
    for (r = b->block + k; r < b->block + STBL_BANK_SIZE; r ++) {      
      if (r->string != NULL) {
	i = r->value;
	gc_mark_term(table, i);
      }
    }
    k = 0;
  }

  // mark terms with root_flag == 1
  for (i=0; i<table->nelems; i++) {
    if (table->kind[i] != UNUSED_TERM && tst_bit(table->mark, i)) {
      gc_mark_term(table, i);
    }
  }  
}


/*
 * Garbage collection
 */
void term_table_garbage_collection(term_table_t *table) {
  int32_t n;
  term_t i;
  int_queue_t queue;
  byte_t *mark;
  term_bit_marker_t bit_marker;
  node_table_t *nodes;

  // initialize gc_mark, mark_queue, bdd_marker
  init_int_queue(&queue, 0);
  n = table->nelems;
  mark = allocate_bitvector(n);
  clear_bitvector(mark, n);
  nodes = table->bv_manager->bm;

  init_bit_marker(&bit_marker.marker, nodes, mark_term_from_bit_expr);
  bit_marker.nodes = nodes;
  bit_marker.pm = &table->bv_manager->pm;
  bit_marker.mark = mark;
  bit_marker.q = &queue;

  table->gc_mark = mark;
  table->gc_mark_queue = &queue;
  table->gc_bit_marker = &bit_marker;

  // mark root terms and all reachable subterms
  gc_mark_term(table, false_term_id);
  gc_mark_term(table, true_term_id);
  mark_live_terms(table);

  table->gc_notifier(table);

  // delete all unmarked terms
  for (i=0; i<n; i++) {
    if (! tst_bit(mark, i)) {
      erase_hcons_record(table, i);
      erase_term(table, i);
    }
  }

  // delete the dead nodes in the bit node table
  node_table_garbage_collection(nodes);

  // cleanup
  table->gc_mark = NULL;
  table->gc_mark_queue = NULL;
  table->gc_bit_marker = NULL;
  delete_bitvector(mark);
  delete_int_queue(&queue);
}

#endif
