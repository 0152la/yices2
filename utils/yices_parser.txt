Yices Parser Restricted to Booelan and Bivector operations.

The parser code is in src/yices_parser.c and src/yices_parser.h.
It's an encoding of a recursive descent parser. It relies on
an automaton defined by types and transition tables contained
in 'src/yices_parse_tables.h'.

That file is built from 'utils/yices_parser_tables.h' and a set of
tables generated by 'utils/table_builder.c'.


Grammar
-------

 command  ::=
          ( define-type <symbol> <type> )
        | ( define <symbol> :: <type> )
        | ( define <symbol> :: <type> <expression> )
        | ( assert <expression> )
        | ( exit )
        | ( check )
        | ( push )
        | ( pop )
        | ( reset )
        | ( show-model )
        | ( eval <expression> )
        | ( echo <string> )
        | ( include <string> )
        | ( set-param <symbol> <immediate-value> )
        | ( show-param <symbol> )
        | ( show-params )
        | ( show-stats )
        | ( reset-stats )
        | ( set-timeout <number> )
        | ( show-timeout )
        | ( dump-context )
        | ( help )
        | ( help <string> )
        | ( help <symbol> )
        | EOS

immediate-value :: =
          true
        | false
        | rational
        | symbol


symbol-list ::=  <symbol> | <symbol> <symbol-list>

type ::=
          bool
        | ( bitvector <rational> )

expression ::=
         true
       | false
       | <rational>
       | <binary bv>
       | <hexa bv>
       | <symbol>
       | ( let ( <binding-list> ) <expression> )
       | ( <function> <expression-list> )

function ::=
         <function-keyword>
       | <expression>

function-keyword ::=
        if      ite     =       /=      distinct

        or      and     not     xor     <=>     =>

        mk-bv   bv-add  bv-sub  bv-mul  bv-neg  bv-pow
        bv-not  bv-and  bv-or   bv-xor
        bv-shift-left0  bv-shift-left1  bv-shift-right0 bv-shift-right1
        bv-ashift-right bv-rotate-left  bv-rotate-right
        bv-extract      bv-concat       bv-repeat
        bv-sign-extend  bv-zero-extend  bv-ge   bv-gt   bv-le   bv-lt
        bv-sge  bv-sgt  bv-sle  bv-slt  bv-shl  bv-lshr bv-ashr
        bv-div  bv-rem  bv-sdiv bv-srem bv-smod
        bv-redor        bv-redand       bv-comp




Recursive-descent parser
------------------------

We use three deterministic automata to describe parsing procedures.
Edges are labeled by terminals or by a recursive call to a parsing
procedure. When several transitions are enabled in the same state,
the one listed first has priority (i.e., transitions labeled by
a terminal symbol have priority over recursive calls).

Example:

c9       )                      DONE
         [parse-expression]     c4

means

if state=c9 then
  if token=')' then
    state=DONE
  else
    parse-expression();
    state=c4
  endif




parse-command:
- initial-state = c0
- transition table
c0       (                      c1
c1       define-type            c2
         echo                   c3
         include                c3
         exit                   c4
         check                  c4
         assert                 c5
         define                 c6
         show-model             c4
         eval                   c5
         push                   c4
         pop                    c4
         reset                  c4
         show-params            c4
         show-stats             c4
         reset-stats            c4
         show-timeout           c4
         set-param              c11
         show-param             c13
         set-timeout            c14
         help                   c15
c2       <symbol>               c10
c3       <string>               c4
c4       )                      DONE
c5       [parse-expression]     c4
c6       <symbol>               c7
c7       ::                     c8
c8       [parse-type]           c9
c9       )                      DONE
         [parse-expression]     c4
c10      )                      DONE
         [parse-type]           c4
c11      <symbol>               c12
c12      true                   c4
         false                  c4
         <rational>             c4
         <float>                c4
         <symbol>               c4
c13      <symbol>               c4
c14      <rational>             c4
c15      <symbol>               c4
         <string>               c4
         )                      DONE

parse-type:
- initial state = t0
- transition table
t0      bool                   DONE
        <symbol>               DONE
        (                      t1
t1      bitvector              t4
t4      <rational>             t5
t5      )                      DONE



parse-expression:
- initial state = e0
- transition table
e0      (                      e1
        true                   DONE
        false                  DONE
        <rational>             DONE
        <binary bv>            DONE
        <hexa bv>              DONE
        <symbol>               DONE
e1      <function-keyword>     e2
        let                    e15
e2      [parse-expression]     e3
e3      )                      DONE
        [parse-expression]     e3
e8      [parse-expression]     e9
e9      )                      DONE
e15     (                      e16
e16     (                      e17
e17     <symbol>               e18
e18     [parse-expr]           e19
e19     )                      e20
e20     )                      e8
        <symbol>               e18


Implementation:

Each recursive procedure can be implemented as

   state = initial state
   while (state != DONE) {
      <transitions>
   }

Each transition with a terminal token is equivalent to

   if state=<source> and token=<token> then
      token=next-token();
      state=<destination>

For recursive calls, we use a stack of states.
We push the successor state on the stack, and jump
to the initial state of the recursive function.
The current token is not consumed.

Example:

   "e2      [parse-expression]     e3"

is translated to

   if state=e2 then
      push e3 on the stack;
      state=e0

Return from a procedure is executed when state=DONE, and is
translated to

   state=state on top of the stack;
   pop stack


Initially, the stack contains a bottom marker, and token is
set by calling next-token() in the lexer, and state is set to
the initial state of whatever needs to be parsed (e.g., c0, e0,
or t0). Parsing terminates when the bottom marker is popped
from the stack (by a return). To avoid reading past the parsed
sentence, which is bad in interactive mode, we must not call the
next-token() function if state=bottom marker.


Optimizations:

We can merge equivalent states: c4, t5, e9 (to a new state r0)

We can skip intermediate states whose only
transition is a recursive call. For example,

  "e1  <function-symbol>  e2  [parse-expression] e3"

corresponds to executing two transitions:

  if state=e1 and token=<function-symbol> then
     token=next-token();
     state=e2

  if state=e2 then
     push e3 on the stack;
     state=e0

We can remove e2 and the second transition by rewriting
the first one:

  if state=e1 and token=<function-symbol> then
     token=next-token();
     push e3 on the stack;
     new-state=e0

We can also eliminate the DONE state using the same trick.



Full table
----------

The parser is defined by the following table, which defines a move or
transition for each pair state/token; 'next' means get next token.

The same data is stored in 'utils/yices_parser_tables.h' and it's
used by 'utils/build_tables.c'.


state    token              action

c0       (              next; goto c1
         EOS            return
c1       exit           next; goto r0
         check          next; goto r0
         echo           next; goto c3
         include        next; goto c3
         assert         next; push r0; goto e0
         define-type    next; goto c2
         define         next; goto c6
         show-model     next; goto r0
         eval           next; push r0; goto e0
         push           next; goto r0
         pop            next; goto r0
         reset          next; goto r0
         dump-context   next; goto r0
         set-param      next; goto c11
         show-params    next; goto r0
         show-param     next; goto c13
         show-stats     next; goto r0
         reset-stats    next; goto r0
         show-timeout   next; goto r0
         set-timeout    next; goto c14
         help           next; goto c15
c2       <symbol>       next; push r0; goto t0
c3       <string>       next; goto r0
c6       <symbol>       next; goto c7
c7       ::             next; push c9; goto t0
c9       )              return
         _              push r0; goto e0
c11      <symbol>       next; goto c12
c12      true           next; goto r0
         false          next; goto r0
         <rational>     next; goto r0
         <float>        next; goto r0
         <symbol>       next; goto r0
c13      <symbol>       next; goto r0
c14      <rational>     next; goto r0
c15      <symbol>       next; goto r0
         <string>       next; goto r0
         ...            next; goto r0      --> treat all keywords as symbols here
         )              return

t0       bool           return
         <symbol>       return
         (              next; goto t1
t1       bitvector      next; goto t4
t4       <rational>     next; goto r0

e0       true           return
         false          return
         <rational>     return
         <binary bv>    return
         <hexa bv>      return
         <symbol>       return
         (              next; goto e1
e1       <function-kw>  next; push e3; goto e0
         let            next; goto e15
e3       )              return
         _              push e3; goto e0
e15      (              next; goto e16
e16      (              next; goto e17
e17      <symbol>       next; push e19; goto e0
e19      )              next; goto e20
e20      (              next; goto e17
         )              next; push r0; goto e0

r0       )              return


return means

s := pop-state on top of stack
if s != bottom
   next; goto s
else
   exit




